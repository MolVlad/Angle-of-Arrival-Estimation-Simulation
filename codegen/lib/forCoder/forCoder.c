/*
 * File: forCoder.c
 *
 * MATLAB Coder version            : 4.1
 * C/C++ source code generated on  : 13-Jul-2020 16:00:18
 */

/* Include Files */
#include <math.h>
#include <string.h>
#include "rt_nonfinite.h"
#include "forCoder.h"
#include "forCoder_emxutil.h"
#include "fclose.h"
#include "fileManager.h"
#include "string1.h"
#include "imregionalmax.h"
#include "abs.h"
#include "sum.h"
#include "sort1.h"
#include "diag.h"
#include "eig.h"
#include "kron.h"
#include "exp.h"
#include "sind.h"
#include "hankel.h"
#include "str2double.h"
#include "char.h"
#include "fread.h"
#include "fseek.h"
#include "ftell.h"
#include "sprintf.h"
#include "forCoder_rtwutil.h"
#include <stdio.h>
#include "time.h"

/* Function Declarations */
static int div_s32_floor(int numerator, int denominator);

/* Function Definitions */

/*
 * Arguments    : int numerator
 *                int denominator
 * Return Type  : int
 */
static int div_s32_floor(int numerator, int denominator)
{
  int quotient;
  unsigned int absNumerator;
  unsigned int absDenominator;
  boolean_T quotientNeedsNegation;
  unsigned int tempAbsQuotient;
  if (denominator == 0) {
    if (numerator >= 0) {
      quotient = MAX_int32_T;
    } else {
      quotient = MIN_int32_T;
    }
  } else {
    if (numerator < 0) {
      absNumerator = ~(unsigned int)numerator + 1U;
    } else {
      absNumerator = (unsigned int)numerator;
    }

    if (denominator < 0) {
      absDenominator = ~(unsigned int)denominator + 1U;
    } else {
      absDenominator = (unsigned int)denominator;
    }

    quotientNeedsNegation = ((numerator < 0) != (denominator < 0));
    tempAbsQuotient = absNumerator / absDenominator;
    if (quotientNeedsNegation) {
      absNumerator %= absDenominator;
      if (absNumerator > 0U) {
        tempAbsQuotient++;
      }

      quotient = -(int)tempAbsQuotient;
    } else {
      quotient = (int)tempAbsQuotient;
    }
  }

  return quotient;
}

/*
 * Arguments    : double seed
 * Return Type  : void
 */
void forCoder(double seed)
{
  long int end = time(NULL);
  printf("programm start: %s\n", ctime(&end));

  emxArray_char_T *s;
  double cdiff;
  int i0;
  char seed_str[5];
  int loop_ub;
  int i1;
  char filename_Value[35];
  static const char cv0[26] = { 'e', 'x', 'p', 'e', 'r', 'i', 'm', 'e', 'n', 't',
    '/', 'w', 'i', 'n', 'n', 'e', 'r', '_', 'c', 's', 'i', '/', 'c', 's', 'i',
    '_' };

  signed char fileid;
  static unsigned char buffer[2097152];
  int remaining;
  int b_index;
  emxArray_real_T *dataRead;
  emxArray_int32_T *r0;
  boolean_T exitg1;
  int nm1d2;
  emxArray_uint8_T *b_buffer;
  double apnd;
  emxArray_char_T *str;
  int i2;
  int k;
  emxArray_char_T *b_str;
  int i;
  int j;
  unsigned char u0;
  emxArray_creal_T *matrixCSI;
  emxArray_creal_T *smoothedMatrixCSI;
  emxArray_creal_T *D;
  emxArray_creal_T *De;
  emxArray_creal_T *tmp;
  static creal_T y[28800];
  emxArray_creal_T *conjCsiTracePerPacket;
  emxArray_creal_T *steeringVector;
  emxArray_real_T *nsDelayAngleSpotfiEstimated;
  emxArray_creal_T *mat;
  emxArray_creal_T *Rxx;
  emxArray_creal_T *Pn;
  emxArray_boolean_T *isStrongEnough;
  emxArray_real_T *newEstimation;
  emxArray_creal_T *Utmp;
  emxArray_creal_T *r1;
  emxArray_boolean_T *r2;
  emxArray_boolean_T *r3;
  emxArray_int32_T *r4;
  emxArray_int32_T *r5;
  emxArray_creal_T *b;
  emxArray_creal_T *b_y;
  emxArray_int32_T *ii;
  emxArray_int16_T *vk;
  emxArray_real_T *varargin_1;
  emxArray_creal_T *r6;
  emxArray_creal_T *r7;
  emxArray_creal_T *r8;
  emxArray_real_T *r9;
  emxArray_creal_T *b_steeringVector;
  emxArray_real_T *b_newEstimation;
  emxArray_real_T *b_nsDelayAngleSpotfiEstimated;
  int ant;
  int b_ant;
  int p;
  int b_p;
  int perSpec;
  int numberOfSpectrums;
  int loop_ub_tmp;
  int band;
  int b_band;
  int dec;
  int subCarrIndEnd;
  int subCarrIndStep;
  int subCarrInd_size_idx_1;
  int varargin_2;
  int numberOfSubcarrierSubsets;
  int smoothing;
  signed char subCarrInd_data[117];
  int subarrayNum;
  int numberOfAntennaInSubset;
  double a;
  double b_b;
  int backw;
  static const signed char iv0[2] = { 1, 0 };

  int numberOfSourses;
  int b_loop_ub;
  int b_loop_ub_tmp;
  int i3;
  int c_loop_ub;
  int d_loop_ub;
  int c_loop_ub_tmp;
  int e_loop_ub;
  int d_loop_ub_tmp;
  int i4;
  int t;
  signed char y_data[58];
  int b_s;
  int i5;
  creal_T csiFromEachPacket_data[944];
  double b_y_data[8];
  double dv0[1801];
  static const double dv1[1801] = { -90.0, -89.9, -89.8, -89.7, -89.6, -89.5,
    -89.4, -89.3, -89.2, -89.1, -89.0, -88.9, -88.8, -88.7, -88.6, -88.5, -88.4,
    -88.3, -88.2, -88.1, -88.0, -87.9, -87.8, -87.7, -87.6, -87.5, -87.4, -87.3,
    -87.2, -87.1, -87.0, -86.9, -86.8, -86.7, -86.6, -86.5, -86.4, -86.3, -86.2,
    -86.1, -86.0, -85.9, -85.8, -85.7, -85.6, -85.5, -85.4, -85.3, -85.2, -85.1,
    -85.0, -84.9, -84.8, -84.7, -84.6, -84.5, -84.4, -84.3, -84.2, -84.1, -84.0,
    -83.9, -83.8, -83.7, -83.6, -83.5, -83.4, -83.3, -83.2, -83.1, -83.0, -82.9,
    -82.8, -82.7, -82.6, -82.5, -82.4, -82.3, -82.2, -82.1, -82.0, -81.9, -81.8,
    -81.7, -81.6, -81.5, -81.4, -81.3, -81.2, -81.1, -81.0, -80.9, -80.8, -80.7,
    -80.6, -80.5, -80.4, -80.3, -80.2, -80.1, -80.0, -79.9, -79.8, -79.7, -79.6,
    -79.5, -79.4, -79.3, -79.2, -79.1, -79.0, -78.9, -78.8, -78.7, -78.6, -78.5,
    -78.4, -78.3, -78.2, -78.1, -78.0, -77.9, -77.8, -77.7, -77.6, -77.5, -77.4,
    -77.3, -77.2, -77.1, -77.0, -76.9, -76.8, -76.7, -76.6, -76.5, -76.4, -76.3,
    -76.2, -76.1, -76.0, -75.9, -75.8, -75.7, -75.6, -75.5, -75.4, -75.3, -75.2,
    -75.1, -75.0, -74.9, -74.8, -74.7, -74.6, -74.5, -74.4, -74.3, -74.2, -74.1,
    -74.0, -73.9, -73.8, -73.7, -73.6, -73.5, -73.4, -73.3, -73.2, -73.1, -73.0,
    -72.9, -72.8, -72.7, -72.6, -72.5, -72.4, -72.3, -72.2, -72.1, -72.0, -71.9,
    -71.8, -71.7, -71.6, -71.5, -71.4, -71.3, -71.2, -71.1, -71.0, -70.9, -70.8,
    -70.7, -70.6, -70.5, -70.4, -70.3, -70.2, -70.1, -70.0, -69.9, -69.8, -69.7,
    -69.6, -69.5, -69.4, -69.3, -69.2, -69.1, -69.0, -68.9, -68.8, -68.7, -68.6,
    -68.5, -68.4, -68.3, -68.2, -68.1, -68.0, -67.9, -67.8, -67.7, -67.6, -67.5,
    -67.4, -67.3, -67.2, -67.1, -67.0, -66.9, -66.8, -66.7, -66.6, -66.5, -66.4,
    -66.3, -66.2, -66.1, -66.0, -65.9, -65.8, -65.7, -65.6, -65.5, -65.4, -65.3,
    -65.2, -65.1, -65.0, -64.9, -64.8, -64.7, -64.6, -64.5, -64.4, -64.3, -64.2,
    -64.1, -64.0, -63.9, -63.8, -63.7, -63.599999999999994, -63.5, -63.4, -63.3,
    -63.2, -63.099999999999994, -63.0, -62.9, -62.8, -62.7, -62.599999999999994,
    -62.5, -62.4, -62.3, -62.2, -62.099999999999994, -62.0, -61.9, -61.8, -61.7,
    -61.599999999999994, -61.5, -61.4, -61.3, -61.2, -61.099999999999994, -61.0,
    -60.9, -60.8, -60.7, -60.599999999999994, -60.5, -60.4, -60.3, -60.2,
    -60.099999999999994, -60.0, -59.9, -59.8, -59.7, -59.599999999999994, -59.5,
    -59.4, -59.3, -59.2, -59.099999999999994, -59.0, -58.9, -58.8, -58.7,
    -58.599999999999994, -58.5, -58.4, -58.3, -58.2, -58.099999999999994, -58.0,
    -57.9, -57.8, -57.699999999999996, -57.6, -57.5, -57.4, -57.3,
    -57.199999999999996, -57.1, -57.0, -56.9, -56.8, -56.699999999999996, -56.6,
    -56.5, -56.4, -56.3, -56.199999999999996, -56.1, -56.0, -55.9, -55.8,
    -55.699999999999996, -55.6, -55.5, -55.4, -55.3, -55.199999999999996, -55.1,
    -55.0, -54.9, -54.8, -54.699999999999996, -54.6, -54.5, -54.4, -54.3,
    -54.199999999999996, -54.1, -54.0, -53.9, -53.8, -53.699999999999996, -53.6,
    -53.5, -53.4, -53.3, -53.199999999999996, -53.1, -53.0, -52.9, -52.8,
    -52.699999999999996, -52.6, -52.5, -52.4, -52.3, -52.199999999999996, -52.1,
    -52.0, -51.9, -51.8, -51.699999999999996, -51.599999999999994, -51.5, -51.4,
    -51.3, -51.199999999999996, -51.099999999999994, -51.0, -50.9, -50.8,
    -50.699999999999996, -50.599999999999994, -50.5, -50.4, -50.3,
    -50.199999999999996, -50.099999999999994, -50.0, -49.9, -49.8,
    -49.699999999999996, -49.599999999999994, -49.5, -49.4, -49.3,
    -49.199999999999996, -49.099999999999994, -49.0, -48.9, -48.8,
    -48.699999999999996, -48.599999999999994, -48.5, -48.4, -48.3,
    -48.199999999999996, -48.099999999999994, -48.0, -47.9, -47.8,
    -47.699999999999996, -47.599999999999994, -47.5, -47.4, -47.3,
    -47.199999999999996, -47.099999999999994, -47.0, -46.9, -46.8,
    -46.699999999999996, -46.599999999999994, -46.5, -46.4, -46.3,
    -46.199999999999996, -46.099999999999994, -46.0, -45.9, -45.8,
    -45.699999999999996, -45.599999999999994, -45.5, -45.4, -45.3,
    -45.199999999999996, -45.099999999999994, -45.0, -44.9, -44.8,
    -44.699999999999996, -44.599999999999994, -44.5, -44.4, -44.3,
    -44.199999999999996, -44.099999999999994, -44.0, -43.9, -43.8,
    -43.699999999999996, -43.599999999999994, -43.5, -43.4, -43.3,
    -43.199999999999996, -43.099999999999994, -43.0, -42.9, -42.8,
    -42.699999999999996, -42.599999999999994, -42.5, -42.4, -42.3,
    -42.199999999999996, -42.099999999999994, -42.0, -41.9, -41.8,
    -41.699999999999996, -41.599999999999994, -41.5, -41.4, -41.3,
    -41.199999999999996, -41.099999999999994, -41.0, -40.9, -40.8,
    -40.699999999999996, -40.599999999999994, -40.5, -40.4, -40.3,
    -40.199999999999996, -40.099999999999994, -40.0, -39.9, -39.8,
    -39.699999999999996, -39.599999999999994, -39.5, -39.4, -39.3,
    -39.199999999999996, -39.099999999999994, -39.0, -38.9, -38.8,
    -38.699999999999996, -38.599999999999994, -38.5, -38.4, -38.3,
    -38.199999999999996, -38.099999999999994, -38.0, -37.9, -37.8,
    -37.699999999999996, -37.599999999999994, -37.5, -37.4, -37.3,
    -37.199999999999996, -37.099999999999994, -37.0, -36.9, -36.8,
    -36.699999999999996, -36.599999999999994, -36.5, -36.4, -36.3,
    -36.199999999999996, -36.099999999999994, -36.0, -35.9, -35.8,
    -35.699999999999996, -35.599999999999994, -35.5, -35.4, -35.3,
    -35.199999999999996, -35.099999999999994, -35.0, -34.9, -34.8,
    -34.699999999999996, -34.599999999999994, -34.5, -34.4, -34.3,
    -34.199999999999996, -34.099999999999994, -34.0, -33.9, -33.8,
    -33.699999999999996, -33.599999999999994, -33.5, -33.4, -33.3,
    -33.199999999999996, -33.099999999999994, -33.0, -32.9, -32.8,
    -32.699999999999996, -32.599999999999994, -32.5, -32.4, -32.3,
    -32.199999999999996, -32.099999999999994, -32.0, -31.9, -31.799999999999997,
    -31.699999999999996, -31.599999999999994, -31.5, -31.4, -31.299999999999997,
    -31.199999999999996, -31.099999999999994, -31.0, -30.9, -30.799999999999997,
    -30.699999999999996, -30.599999999999994, -30.5, -30.4, -30.299999999999997,
    -30.199999999999996, -30.099999999999994, -30.0, -29.9, -29.799999999999997,
    -29.699999999999996, -29.599999999999994, -29.5, -29.4, -29.299999999999997,
    -29.199999999999996, -29.099999999999994, -29.0, -28.9, -28.799999999999997,
    -28.699999999999996, -28.599999999999994, -28.5, -28.4, -28.299999999999997,
    -28.199999999999996, -28.099999999999994, -28.0, -27.9, -27.799999999999997,
    -27.699999999999996, -27.599999999999994, -27.5, -27.4, -27.299999999999997,
    -27.199999999999996, -27.099999999999994, -27.0, -26.9, -26.799999999999997,
    -26.699999999999996, -26.599999999999994, -26.5, -26.4, -26.299999999999997,
    -26.199999999999996, -26.099999999999994, -26.0, -25.899999999999991,
    -25.799999999999997, -25.700000000000003, -25.599999999999994, -25.5,
    -25.399999999999991, -25.299999999999997, -25.200000000000003,
    -25.099999999999994, -25.0, -24.899999999999991, -24.799999999999997,
    -24.700000000000003, -24.599999999999994, -24.5, -24.399999999999991,
    -24.299999999999997, -24.200000000000003, -24.099999999999994, -24.0,
    -23.899999999999991, -23.799999999999997, -23.700000000000003,
    -23.599999999999994, -23.5, -23.399999999999991, -23.299999999999997,
    -23.200000000000003, -23.099999999999994, -23.0, -22.899999999999991,
    -22.799999999999997, -22.700000000000003, -22.599999999999994, -22.5,
    -22.399999999999991, -22.299999999999997, -22.200000000000003,
    -22.099999999999994, -22.0, -21.899999999999991, -21.799999999999997,
    -21.700000000000003, -21.599999999999994, -21.5, -21.399999999999991,
    -21.299999999999997, -21.200000000000003, -21.099999999999994, -21.0,
    -20.899999999999991, -20.799999999999997, -20.700000000000003,
    -20.599999999999994, -20.5, -20.399999999999991, -20.299999999999997,
    -20.200000000000003, -20.099999999999994, -20.0, -19.899999999999991,
    -19.799999999999997, -19.700000000000003, -19.599999999999994, -19.5,
    -19.399999999999991, -19.299999999999997, -19.200000000000003,
    -19.099999999999994, -19.0, -18.899999999999991, -18.799999999999997,
    -18.700000000000003, -18.599999999999994, -18.5, -18.399999999999991,
    -18.299999999999997, -18.200000000000003, -18.099999999999994, -18.0,
    -17.899999999999991, -17.799999999999997, -17.700000000000003,
    -17.599999999999994, -17.5, -17.399999999999991, -17.299999999999997,
    -17.200000000000003, -17.099999999999994, -17.0, -16.899999999999991,
    -16.799999999999997, -16.700000000000003, -16.599999999999994, -16.5,
    -16.399999999999991, -16.299999999999997, -16.200000000000003,
    -16.099999999999994, -16.0, -15.899999999999991, -15.799999999999997,
    -15.700000000000003, -15.599999999999994, -15.5, -15.399999999999991,
    -15.299999999999997, -15.200000000000003, -15.099999999999994, -15.0,
    -14.899999999999991, -14.799999999999997, -14.700000000000003,
    -14.599999999999994, -14.5, -14.399999999999991, -14.299999999999997,
    -14.200000000000003, -14.099999999999994, -14.0, -13.899999999999991,
    -13.799999999999997, -13.700000000000003, -13.599999999999994, -13.5,
    -13.399999999999991, -13.299999999999997, -13.199999999999989,
    -13.099999999999994, -13.0, -12.899999999999991, -12.799999999999997,
    -12.699999999999989, -12.599999999999994, -12.5, -12.399999999999991,
    -12.299999999999997, -12.199999999999989, -12.099999999999994, -12.0,
    -11.899999999999991, -11.799999999999997, -11.699999999999989,
    -11.599999999999994, -11.5, -11.399999999999991, -11.299999999999997,
    -11.199999999999989, -11.099999999999994, -11.0, -10.899999999999991,
    -10.799999999999997, -10.699999999999989, -10.599999999999994, -10.5,
    -10.399999999999991, -10.299999999999997, -10.199999999999989,
    -10.099999999999994, -10.0, -9.8999999999999915, -9.7999999999999972,
    -9.6999999999999886, -9.5999999999999943, -9.5, -9.3999999999999915,
    -9.2999999999999972, -9.1999999999999886, -9.0999999999999943, -9.0,
    -8.8999999999999915, -8.7999999999999972, -8.6999999999999886,
    -8.5999999999999943, -8.5, -8.3999999999999915, -8.2999999999999972,
    -8.1999999999999886, -8.0999999999999943, -8.0, -7.8999999999999915,
    -7.7999999999999972, -7.6999999999999886, -7.5999999999999943, -7.5,
    -7.3999999999999915, -7.2999999999999972, -7.1999999999999886,
    -7.0999999999999943, -7.0, -6.8999999999999915, -6.7999999999999972,
    -6.6999999999999886, -6.5999999999999943, -6.5, -6.3999999999999915,
    -6.2999999999999972, -6.1999999999999886, -6.0999999999999943, -6.0,
    -5.8999999999999915, -5.7999999999999972, -5.6999999999999886,
    -5.5999999999999943, -5.5, -5.3999999999999915, -5.2999999999999972,
    -5.1999999999999886, -5.0999999999999943, -5.0, -4.8999999999999915,
    -4.7999999999999972, -4.6999999999999886, -4.5999999999999943, -4.5,
    -4.3999999999999915, -4.2999999999999972, -4.1999999999999886,
    -4.0999999999999943, -4.0, -3.8999999999999915, -3.7999999999999972,
    -3.6999999999999886, -3.5999999999999943, -3.5, -3.3999999999999915,
    -3.2999999999999972, -3.1999999999999886, -3.0999999999999943, -3.0,
    -2.8999999999999915, -2.7999999999999972, -2.6999999999999886,
    -2.5999999999999943, -2.5, -2.3999999999999915, -2.2999999999999972,
    -2.1999999999999886, -2.0999999999999943, -2.0, -1.8999999999999915,
    -1.7999999999999972, -1.6999999999999886, -1.5999999999999943, -1.5,
    -1.3999999999999915, -1.2999999999999972, -1.1999999999999886,
    -1.0999999999999943, -1.0, -0.89999999999999147, -0.79999999999999716,
    -0.69999999999998863, -0.59999999999999432, -0.5, -0.39999999999999147,
    -0.29999999999999716, -0.19999999999998863, -0.099999999999994316, 0.0,
    0.10000000000000853, 0.20000000000000284, 0.30000000000001137,
    0.40000000000000568, 0.5, 0.60000000000000853, 0.70000000000000284,
    0.80000000000001137, 0.90000000000000568, 1.0, 1.1000000000000085,
    1.2000000000000028, 1.3000000000000114, 1.4000000000000057, 1.5,
    1.6000000000000085, 1.7000000000000028, 1.8000000000000114,
    1.9000000000000057, 2.0, 2.1000000000000085, 2.2000000000000028,
    2.3000000000000114, 2.4000000000000057, 2.5, 2.6000000000000085,
    2.7000000000000028, 2.8000000000000114, 2.9000000000000057, 3.0,
    3.1000000000000085, 3.2000000000000028, 3.3000000000000114,
    3.4000000000000057, 3.5, 3.6000000000000085, 3.7000000000000028,
    3.8000000000000114, 3.9000000000000057, 4.0, 4.1000000000000085,
    4.2000000000000028, 4.3000000000000114, 4.4000000000000057, 4.5,
    4.6000000000000085, 4.7000000000000028, 4.8000000000000114,
    4.9000000000000057, 5.0, 5.1000000000000085, 5.2000000000000028,
    5.3000000000000114, 5.4000000000000057, 5.5, 5.6000000000000085,
    5.7000000000000028, 5.8000000000000114, 5.9000000000000057, 6.0,
    6.1000000000000085, 6.2000000000000028, 6.3000000000000114,
    6.4000000000000057, 6.5, 6.6000000000000085, 6.7000000000000028,
    6.8000000000000114, 6.9000000000000057, 7.0, 7.1000000000000085,
    7.2000000000000028, 7.3000000000000114, 7.4000000000000057, 7.5,
    7.6000000000000085, 7.7000000000000028, 7.8000000000000114,
    7.9000000000000057, 8.0, 8.1000000000000085, 8.2000000000000028,
    8.3000000000000114, 8.4000000000000057, 8.5, 8.6000000000000085,
    8.7000000000000028, 8.8000000000000114, 8.9000000000000057, 9.0,
    9.1000000000000085, 9.2000000000000028, 9.3000000000000114,
    9.4000000000000057, 9.5, 9.6000000000000085, 9.7000000000000028,
    9.8000000000000114, 9.9000000000000057, 10.0, 10.100000000000009,
    10.200000000000003, 10.300000000000011, 10.400000000000006, 10.5,
    10.600000000000009, 10.700000000000003, 10.800000000000011,
    10.900000000000006, 11.0, 11.100000000000009, 11.200000000000003,
    11.300000000000011, 11.400000000000006, 11.5, 11.600000000000009,
    11.700000000000003, 11.800000000000011, 11.900000000000006, 12.0,
    12.100000000000009, 12.200000000000003, 12.300000000000011,
    12.400000000000006, 12.5, 12.600000000000009, 12.700000000000003,
    12.800000000000011, 12.900000000000006, 13.0, 13.100000000000009,
    13.200000000000003, 13.300000000000011, 13.400000000000006, 13.5,
    13.600000000000009, 13.700000000000003, 13.800000000000011,
    13.900000000000006, 14.0, 14.100000000000009, 14.200000000000003,
    14.300000000000011, 14.400000000000006, 14.5, 14.600000000000009,
    14.700000000000003, 14.800000000000011, 14.900000000000006, 15.0,
    15.100000000000009, 15.200000000000003, 15.300000000000011,
    15.400000000000006, 15.5, 15.600000000000009, 15.700000000000003,
    15.800000000000011, 15.900000000000006, 16.0, 16.100000000000009,
    16.200000000000003, 16.300000000000011, 16.400000000000006, 16.5,
    16.600000000000009, 16.700000000000003, 16.800000000000011,
    16.900000000000006, 17.0, 17.100000000000009, 17.200000000000003,
    17.300000000000011, 17.400000000000006, 17.5, 17.600000000000009,
    17.700000000000003, 17.800000000000011, 17.900000000000006, 18.0,
    18.100000000000009, 18.200000000000003, 18.300000000000011,
    18.400000000000006, 18.5, 18.600000000000009, 18.700000000000003,
    18.800000000000011, 18.900000000000006, 19.0, 19.100000000000009,
    19.200000000000003, 19.300000000000011, 19.400000000000006, 19.5,
    19.600000000000009, 19.700000000000003, 19.800000000000011,
    19.900000000000006, 20.0, 20.100000000000009, 20.200000000000003,
    20.300000000000011, 20.400000000000006, 20.5, 20.600000000000009,
    20.700000000000003, 20.800000000000011, 20.900000000000006, 21.0,
    21.100000000000009, 21.200000000000003, 21.300000000000011,
    21.400000000000006, 21.5, 21.600000000000009, 21.700000000000003,
    21.800000000000011, 21.900000000000006, 22.0, 22.100000000000009,
    22.200000000000003, 22.300000000000011, 22.400000000000006, 22.5,
    22.600000000000009, 22.700000000000003, 22.800000000000011,
    22.900000000000006, 23.0, 23.100000000000009, 23.200000000000003,
    23.300000000000011, 23.400000000000006, 23.5, 23.600000000000009,
    23.700000000000003, 23.800000000000011, 23.900000000000006, 24.0,
    24.100000000000009, 24.200000000000003, 24.300000000000011,
    24.400000000000006, 24.5, 24.600000000000009, 24.700000000000003,
    24.800000000000011, 24.900000000000006, 25.0, 25.100000000000009,
    25.200000000000003, 25.300000000000011, 25.400000000000006, 25.5,
    25.600000000000009, 25.700000000000003, 25.800000000000011,
    25.900000000000006, 26.0, 26.100000000000009, 26.200000000000003,
    26.300000000000011, 26.400000000000006, 26.5, 26.600000000000009,
    26.700000000000003, 26.800000000000011, 26.900000000000006, 27.0,
    27.100000000000009, 27.200000000000003, 27.300000000000011,
    27.400000000000006, 27.5, 27.600000000000009, 27.700000000000003,
    27.800000000000011, 27.900000000000006, 28.0, 28.100000000000009,
    28.200000000000003, 28.300000000000011, 28.400000000000006, 28.5,
    28.600000000000009, 28.700000000000003, 28.800000000000011,
    28.900000000000006, 29.0, 29.100000000000009, 29.200000000000003,
    29.300000000000011, 29.400000000000006, 29.5, 29.600000000000009,
    29.700000000000003, 29.800000000000011, 29.900000000000006, 30.0,
    30.100000000000009, 30.200000000000003, 30.300000000000011,
    30.400000000000006, 30.5, 30.600000000000009, 30.700000000000003,
    30.800000000000011, 30.900000000000006, 31.0, 31.100000000000009,
    31.200000000000003, 31.300000000000011, 31.400000000000006, 31.5,
    31.600000000000009, 31.700000000000003, 31.800000000000011,
    31.900000000000006, 32.0, 32.100000000000009, 32.2, 32.300000000000011,
    32.400000000000006, 32.5, 32.600000000000009, 32.7, 32.800000000000011,
    32.900000000000006, 33.0, 33.100000000000009, 33.2, 33.300000000000011,
    33.400000000000006, 33.5, 33.600000000000009, 33.7, 33.800000000000011,
    33.900000000000006, 34.0, 34.100000000000009, 34.2, 34.300000000000011,
    34.400000000000006, 34.5, 34.600000000000009, 34.7, 34.800000000000011,
    34.900000000000006, 35.0, 35.100000000000009, 35.2, 35.300000000000011,
    35.400000000000006, 35.5, 35.600000000000009, 35.7, 35.800000000000011,
    35.900000000000006, 36.0, 36.100000000000009, 36.2, 36.300000000000011,
    36.400000000000006, 36.5, 36.600000000000009, 36.7, 36.800000000000011,
    36.900000000000006, 37.0, 37.100000000000009, 37.2, 37.300000000000011,
    37.400000000000006, 37.5, 37.600000000000009, 37.7, 37.800000000000011,
    37.900000000000006, 38.0, 38.099999999999994, 38.200000000000017,
    38.300000000000011, 38.400000000000006, 38.5, 38.599999999999994,
    38.700000000000017, 38.800000000000011, 38.900000000000006, 39.0,
    39.099999999999994, 39.200000000000017, 39.300000000000011,
    39.400000000000006, 39.5, 39.599999999999994, 39.700000000000017,
    39.800000000000011, 39.900000000000006, 40.0, 40.099999999999994,
    40.200000000000017, 40.300000000000011, 40.400000000000006, 40.5,
    40.599999999999994, 40.700000000000017, 40.800000000000011,
    40.900000000000006, 41.0, 41.099999999999994, 41.200000000000017,
    41.300000000000011, 41.400000000000006, 41.5, 41.599999999999994,
    41.700000000000017, 41.800000000000011, 41.900000000000006, 42.0,
    42.099999999999994, 42.200000000000017, 42.300000000000011,
    42.400000000000006, 42.5, 42.599999999999994, 42.700000000000017,
    42.800000000000011, 42.900000000000006, 43.0, 43.099999999999994,
    43.200000000000017, 43.300000000000011, 43.400000000000006, 43.5,
    43.599999999999994, 43.700000000000017, 43.800000000000011,
    43.900000000000006, 44.0, 44.099999999999994, 44.200000000000017,
    44.300000000000011, 44.400000000000006, 44.5, 44.599999999999994,
    44.700000000000017, 44.800000000000011, 44.900000000000006, 45.0,
    45.099999999999994, 45.200000000000017, 45.300000000000011,
    45.400000000000006, 45.5, 45.599999999999994, 45.700000000000017,
    45.800000000000011, 45.900000000000006, 46.0, 46.099999999999994,
    46.200000000000017, 46.300000000000011, 46.400000000000006, 46.5,
    46.599999999999994, 46.700000000000017, 46.800000000000011,
    46.900000000000006, 47.0, 47.099999999999994, 47.200000000000017,
    47.300000000000011, 47.400000000000006, 47.5, 47.599999999999994,
    47.700000000000017, 47.800000000000011, 47.900000000000006, 48.0,
    48.099999999999994, 48.200000000000017, 48.300000000000011,
    48.400000000000006, 48.5, 48.599999999999994, 48.700000000000017,
    48.800000000000011, 48.900000000000006, 49.0, 49.099999999999994,
    49.200000000000017, 49.300000000000011, 49.400000000000006, 49.5,
    49.599999999999994, 49.700000000000017, 49.800000000000011,
    49.900000000000006, 50.0, 50.099999999999994, 50.200000000000017,
    50.300000000000011, 50.400000000000006, 50.5, 50.599999999999994,
    50.700000000000017, 50.800000000000011, 50.900000000000006, 51.0,
    51.099999999999994, 51.200000000000017, 51.300000000000011,
    51.400000000000006, 51.5, 51.599999999999994, 51.700000000000017,
    51.800000000000011, 51.900000000000006, 52.0, 52.099999999999994,
    52.200000000000017, 52.300000000000011, 52.400000000000006, 52.5,
    52.599999999999994, 52.700000000000017, 52.800000000000011,
    52.900000000000006, 53.0, 53.099999999999994, 53.200000000000017,
    53.300000000000011, 53.400000000000006, 53.5, 53.599999999999994,
    53.700000000000017, 53.800000000000011, 53.900000000000006, 54.0,
    54.099999999999994, 54.200000000000017, 54.300000000000011,
    54.400000000000006, 54.5, 54.599999999999994, 54.700000000000017,
    54.800000000000011, 54.900000000000006, 55.0, 55.099999999999994,
    55.200000000000017, 55.300000000000011, 55.400000000000006, 55.5,
    55.599999999999994, 55.700000000000017, 55.800000000000011,
    55.900000000000006, 56.0, 56.099999999999994, 56.200000000000017,
    56.300000000000011, 56.400000000000006, 56.5, 56.599999999999994,
    56.700000000000017, 56.800000000000011, 56.900000000000006, 57.0,
    57.099999999999994, 57.200000000000017, 57.300000000000011,
    57.400000000000006, 57.5, 57.599999999999994, 57.700000000000017,
    57.800000000000011, 57.900000000000006, 58.0, 58.099999999999994,
    58.200000000000017, 58.300000000000011, 58.400000000000006, 58.5,
    58.599999999999994, 58.700000000000017, 58.800000000000011,
    58.900000000000006, 59.0, 59.099999999999994, 59.200000000000017,
    59.300000000000011, 59.400000000000006, 59.5, 59.599999999999994,
    59.700000000000017, 59.800000000000011, 59.900000000000006, 60.0,
    60.099999999999994, 60.200000000000017, 60.300000000000011,
    60.400000000000006, 60.5, 60.599999999999994, 60.700000000000017,
    60.800000000000011, 60.900000000000006, 61.0, 61.099999999999994,
    61.200000000000017, 61.300000000000011, 61.400000000000006, 61.5,
    61.599999999999994, 61.700000000000017, 61.800000000000011,
    61.900000000000006, 62.0, 62.099999999999994, 62.200000000000017,
    62.300000000000011, 62.400000000000006, 62.5, 62.599999999999994,
    62.700000000000017, 62.800000000000011, 62.900000000000006, 63.0,
    63.099999999999994, 63.200000000000017, 63.300000000000011,
    63.400000000000006, 63.5, 63.600000000000023, 63.700000000000017,
    63.800000000000011, 63.900000000000006, 64.0, 64.100000000000023,
    64.200000000000017, 64.300000000000011, 64.4, 64.5, 64.600000000000023,
    64.700000000000017, 64.800000000000011, 64.9, 65.0, 65.100000000000023,
    65.200000000000017, 65.300000000000011, 65.4, 65.5, 65.600000000000023,
    65.700000000000017, 65.800000000000011, 65.9, 66.0, 66.100000000000023,
    66.200000000000017, 66.300000000000011, 66.4, 66.5, 66.600000000000023,
    66.700000000000017, 66.800000000000011, 66.9, 67.0, 67.100000000000023,
    67.200000000000017, 67.300000000000011, 67.4, 67.5, 67.600000000000023,
    67.700000000000017, 67.800000000000011, 67.9, 68.0, 68.100000000000023,
    68.200000000000017, 68.300000000000011, 68.4, 68.5, 68.600000000000023,
    68.700000000000017, 68.800000000000011, 68.9, 69.0, 69.100000000000023,
    69.200000000000017, 69.300000000000011, 69.4, 69.5, 69.600000000000023,
    69.700000000000017, 69.800000000000011, 69.9, 70.0, 70.100000000000023,
    70.200000000000017, 70.300000000000011, 70.4, 70.5, 70.600000000000023,
    70.700000000000017, 70.800000000000011, 70.9, 71.0, 71.100000000000023,
    71.200000000000017, 71.300000000000011, 71.4, 71.5, 71.600000000000023,
    71.700000000000017, 71.800000000000011, 71.9, 72.0, 72.100000000000023,
    72.200000000000017, 72.300000000000011, 72.4, 72.5, 72.600000000000023,
    72.700000000000017, 72.800000000000011, 72.9, 73.0, 73.100000000000023,
    73.200000000000017, 73.300000000000011, 73.4, 73.5, 73.600000000000023,
    73.700000000000017, 73.800000000000011, 73.9, 74.0, 74.100000000000023,
    74.200000000000017, 74.300000000000011, 74.4, 74.5, 74.600000000000023,
    74.700000000000017, 74.800000000000011, 74.9, 75.0, 75.100000000000023,
    75.200000000000017, 75.300000000000011, 75.4, 75.5, 75.600000000000023,
    75.700000000000017, 75.800000000000011, 75.9, 76.0, 76.100000000000023,
    76.200000000000017, 76.300000000000011, 76.4, 76.5, 76.600000000000023,
    76.700000000000017, 76.800000000000011, 76.9, 77.0, 77.100000000000023,
    77.200000000000017, 77.300000000000011, 77.4, 77.5, 77.600000000000023,
    77.700000000000017, 77.800000000000011, 77.9, 78.0, 78.100000000000023,
    78.200000000000017, 78.300000000000011, 78.4, 78.5, 78.600000000000023,
    78.700000000000017, 78.800000000000011, 78.9, 79.0, 79.100000000000023,
    79.200000000000017, 79.300000000000011, 79.4, 79.5, 79.600000000000023,
    79.700000000000017, 79.800000000000011, 79.9, 80.0, 80.100000000000023,
    80.200000000000017, 80.300000000000011, 80.4, 80.5, 80.600000000000023,
    80.700000000000017, 80.800000000000011, 80.9, 81.0, 81.100000000000023,
    81.200000000000017, 81.300000000000011, 81.4, 81.5, 81.600000000000023,
    81.700000000000017, 81.800000000000011, 81.9, 82.0, 82.100000000000023,
    82.200000000000017, 82.300000000000011, 82.4, 82.5, 82.600000000000023,
    82.700000000000017, 82.800000000000011, 82.9, 83.0, 83.100000000000023,
    83.200000000000017, 83.300000000000011, 83.4, 83.5, 83.600000000000023,
    83.700000000000017, 83.800000000000011, 83.9, 84.0, 84.100000000000023,
    84.200000000000017, 84.300000000000011, 84.4, 84.5, 84.600000000000023,
    84.700000000000017, 84.800000000000011, 84.9, 85.0, 85.100000000000023,
    85.200000000000017, 85.300000000000011, 85.4, 85.5, 85.600000000000023,
    85.700000000000017, 85.800000000000011, 85.9, 86.0, 86.100000000000023,
    86.200000000000017, 86.300000000000011, 86.4, 86.5, 86.600000000000023,
    86.700000000000017, 86.800000000000011, 86.9, 87.0, 87.100000000000023,
    87.200000000000017, 87.300000000000011, 87.4, 87.5, 87.600000000000023,
    87.700000000000017, 87.800000000000011, 87.9, 88.0, 88.100000000000023,
    88.200000000000017, 88.300000000000011, 88.4, 88.5, 88.600000000000023,
    88.700000000000017, 88.800000000000011, 88.9, 89.0, 89.100000000000023,
    89.200000000000017, 89.300000000000011, 89.4, 89.5, 89.600000000000023,
    89.700000000000017, 89.800000000000011, 89.9, 90.0 };

  int m;
  creal_T dcv0[1801];
  int csiFromEachPacket_size[1];
  int b_csiFromEachPacket_size[1];
  creal_T b_csiFromEachPacket_data[58];
  int boffset;
  creal_T c_csiFromEachPacket_data[117];
  creal_T dcv1[601];
  static const double dv2[601] = { -3.0000000000000004E-7, -2.99E-7,
    -2.9800000000000005E-7, -2.97E-7, -2.9600000000000006E-7,
    -2.9500000000000003E-7, -2.9400000000000007E-7, -2.9300000000000004E-7,
    -2.92E-7, -2.9100000000000005E-7, -2.9000000000000003E-7,
    -2.8900000000000006E-7, -2.8800000000000004E-7, -2.87E-7,
    -2.8600000000000005E-7, -2.85E-7, -2.8400000000000005E-7,
    -2.8300000000000003E-7, -2.82E-7, -2.8100000000000004E-7, -2.8E-7,
    -2.7900000000000005E-7, -2.7800000000000003E-7, -2.7700000000000006E-7,
    -2.7600000000000004E-7, -2.75E-7, -2.7400000000000004E-7, -2.73E-7,
    -2.7200000000000005E-7, -2.7100000000000003E-7, -2.7000000000000006E-7,
    -2.6900000000000004E-7, -2.68E-7, -2.6700000000000005E-7, -2.66E-7,
    -2.6500000000000006E-7, -2.6400000000000003E-7, -2.6300000000000007E-7,
    -2.6200000000000004E-7, -2.61E-7, -2.6000000000000005E-7,
    -2.5900000000000003E-7, -2.58E-7, -2.5700000000000004E-7, -2.56E-7,
    -2.5500000000000005E-7, -2.54E-7, -2.5300000000000006E-7,
    -2.5200000000000003E-7, -2.51E-7, -2.5000000000000004E-7, -2.49E-7,
    -2.4800000000000005E-7, -2.4700000000000003E-7, -2.4600000000000006E-7,
    -2.4500000000000004E-7, -2.44E-7, -2.4300000000000005E-7, -2.42E-7,
    -2.4100000000000005E-7, -2.4000000000000003E-7, -2.3900000000000006E-7,
    -2.3800000000000004E-7, -2.3700000000000002E-7, -2.3600000000000005E-7,
    -2.3500000000000003E-7, -2.3400000000000003E-7, -2.3300000000000003E-7,
    -2.3200000000000004E-7, -2.3100000000000004E-7, -2.3000000000000002E-7,
    -2.2900000000000005E-7, -2.2800000000000003E-7, -2.2700000000000003E-7,
    -2.2600000000000004E-7, -2.2500000000000002E-7, -2.2400000000000005E-7,
    -2.2300000000000002E-7, -2.2200000000000003E-7, -2.2100000000000003E-7,
    -2.2000000000000004E-7, -2.1900000000000004E-7, -2.1800000000000002E-7,
    -2.1700000000000005E-7, -2.1600000000000003E-7, -2.1500000000000003E-7,
    -2.1400000000000004E-7, -2.1300000000000001E-7, -2.1200000000000005E-7,
    -2.1100000000000002E-7, -2.1000000000000003E-7, -2.0900000000000003E-7,
    -2.0800000000000004E-7, -2.0700000000000004E-7, -2.0600000000000002E-7,
    -2.0500000000000005E-7, -2.0400000000000003E-7, -2.0300000000000003E-7,
    -2.0200000000000004E-7, -2.0100000000000004E-7, -2.0000000000000004E-7,
    -1.9900000000000002E-7, -1.9800000000000005E-7, -1.9700000000000003E-7,
    -1.9600000000000003E-7, -1.9500000000000004E-7, -1.9400000000000002E-7,
    -1.9300000000000005E-7, -1.9200000000000003E-7, -1.9100000000000003E-7,
    -1.9000000000000003E-7, -1.8900000000000004E-7, -1.8800000000000004E-7,
    -1.8700000000000002E-7, -1.8600000000000005E-7, -1.8500000000000003E-7,
    -1.8400000000000003E-7, -1.8300000000000004E-7, -1.8200000000000002E-7,
    -1.8100000000000005E-7, -1.8000000000000002E-7, -1.7900000000000003E-7,
    -1.7800000000000003E-7, -1.7700000000000004E-7, -1.7600000000000004E-7,
    -1.7500000000000002E-7, -1.7400000000000002E-7, -1.7300000000000003E-7,
    -1.7200000000000003E-7, -1.7100000000000004E-7, -1.7000000000000004E-7,
    -1.6900000000000004E-7, -1.6800000000000002E-7, -1.6700000000000003E-7,
    -1.6600000000000003E-7, -1.6500000000000003E-7, -1.6400000000000004E-7,
    -1.6300000000000004E-7, -1.6200000000000002E-7, -1.6100000000000003E-7,
    -1.6000000000000003E-7, -1.5900000000000003E-7, -1.5800000000000004E-7,
    -1.5700000000000004E-7, -1.5600000000000002E-7, -1.5500000000000002E-7,
    -1.5400000000000003E-7, -1.5300000000000003E-7, -1.5200000000000004E-7,
    -1.5100000000000004E-7, -1.5000000000000002E-7, -1.4900000000000002E-7,
    -1.4800000000000003E-7, -1.4700000000000003E-7, -1.4600000000000004E-7,
    -1.4500000000000004E-7, -1.4400000000000002E-7, -1.4300000000000002E-7,
    -1.4200000000000003E-7, -1.4100000000000003E-7, -1.4000000000000004E-7,
    -1.3900000000000004E-7, -1.3800000000000002E-7, -1.3700000000000002E-7,
    -1.3600000000000003E-7, -1.3500000000000003E-7, -1.3400000000000004E-7,
    -1.3300000000000004E-7, -1.3200000000000002E-7, -1.3100000000000002E-7,
    -1.3000000000000003E-7, -1.2900000000000003E-7, -1.2800000000000003E-7,
    -1.2700000000000004E-7, -1.2600000000000002E-7, -1.2500000000000002E-7,
    -1.2400000000000003E-7, -1.2300000000000003E-7, -1.2200000000000003E-7,
    -1.2100000000000004E-7, -1.2000000000000002E-7, -1.1900000000000002E-7,
    -1.1800000000000002E-7, -1.1700000000000003E-7, -1.1600000000000003E-7,
    -1.1500000000000004E-7, -1.1400000000000001E-7, -1.1300000000000002E-7,
    -1.1200000000000002E-7, -1.1100000000000003E-7, -1.1000000000000003E-7,
    -1.0900000000000004E-7, -1.0800000000000001E-7, -1.0700000000000002E-7,
    -1.0600000000000002E-7, -1.0500000000000003E-7, -1.0400000000000003E-7,
    -1.0300000000000004E-7, -1.0200000000000004E-7, -1.0100000000000002E-7,
    -1.0000000000000002E-7, -9.9000000000000026E-8, -9.8000000000000031E-8,
    -9.7000000000000035E-8, -9.6000000000000039E-8, -9.5000000000000017E-8,
    -9.4000000000000021E-8, -9.3000000000000025E-8, -9.200000000000003E-8,
    -9.1000000000000034E-8, -9.0000000000000038E-8, -8.9000000000000016E-8,
    -8.800000000000002E-8, -8.7000000000000025E-8, -8.6000000000000029E-8,
    -8.5000000000000033E-8, -8.4000000000000037E-8, -8.3000000000000015E-8,
    -8.200000000000002E-8, -8.1000000000000024E-8, -8.0000000000000028E-8,
    -7.9000000000000032E-8, -7.8000000000000037E-8, -7.7000000000000015E-8,
    -7.6000000000000019E-8, -7.5000000000000023E-8, -7.4000000000000027E-8,
    -7.3000000000000032E-8, -7.2000000000000036E-8, -7.1000000000000014E-8,
    -7.0000000000000018E-8, -6.9000000000000022E-8, -6.8000000000000027E-8,
    -6.7000000000000031E-8, -6.6000000000000035E-8, -6.5000000000000013E-8,
    -6.4000000000000017E-8, -6.3000000000000022E-8, -6.2000000000000026E-8,
    -6.100000000000003E-8, -6.0000000000000008E-8, -5.9000000000000039E-8,
    -5.8000000000000016E-8, -5.7000000000000047E-8, -5.6000000000000025E-8,
    -5.5E-8, -5.4000000000000034E-8, -5.3000000000000011E-8,
    -5.2000000000000042E-8, -5.100000000000002E-8, -5.0E-8,
    -4.9000000000000028E-8, -4.8000000000000006E-8, -4.7000000000000037E-8,
    -4.6000000000000015E-8, -4.5000000000000046E-8, -4.4000000000000023E-8,
    -4.3E-8, -4.2000000000000032E-8, -4.100000000000001E-8,
    -4.0000000000000041E-8, -3.9000000000000018E-8, -3.8000000000000049E-8,
    -3.7000000000000027E-8, -3.6000000000000005E-8, -3.5000000000000035E-8,
    -3.4000000000000013E-8, -3.3000000000000044E-8, -3.2000000000000022E-8,
    -3.1E-8, -3.000000000000003E-8, -2.9000000000000008E-8,
    -2.8000000000000039E-8, -2.7000000000000017E-8, -2.6000000000000048E-8,
    -2.5000000000000025E-8, -2.4000000000000003E-8, -2.3000000000000034E-8,
    -2.2000000000000012E-8, -2.1000000000000042E-8, -2.000000000000002E-8,
    -1.8999999999999998E-8, -1.8000000000000029E-8, -1.7000000000000007E-8,
    -1.6000000000000037E-8, -1.5000000000000015E-8, -1.4000000000000046E-8,
    -1.3000000000000024E-8, -1.2000000000000002E-8, -1.1000000000000032E-8,
    -1.000000000000001E-8, -9.0000000000000409E-9, -8.0000000000000187E-9,
    -6.9999999999999965E-9, -6.0000000000000273E-9, -5.0000000000000051E-9,
    -4.0000000000000358E-9, -3.0000000000000136E-9, -2.0000000000000444E-9,
    -1.0000000000000222E-9, 0.0, 9.9999999999996925E-10, 1.9999999999999914E-9,
    2.9999999999999607E-9, 3.9999999999999829E-9, 5.0000000000000051E-9,
    5.9999999999999743E-9, 6.9999999999999965E-9, 7.9999999999999658E-9,
    8.9999999999999879E-9, 9.9999999999999572E-9, 1.0999999999999979E-8,
    1.2000000000000002E-8, 1.2999999999999971E-8, 1.3999999999999993E-8,
    1.4999999999999962E-8, 1.5999999999999984E-8, 1.7000000000000007E-8,
    1.7999999999999976E-8, 1.8999999999999998E-8, 1.9999999999999967E-8,
    2.099999999999999E-8, 2.1999999999999959E-8, 2.2999999999999981E-8,
    2.4000000000000003E-8, 2.4999999999999972E-8, 2.5999999999999995E-8,
    2.6999999999999964E-8, 2.7999999999999986E-8, 2.8999999999999955E-8,
    2.9999999999999977E-8, 3.1E-8, 3.1999999999999969E-8, 3.2999999999999991E-8,
    3.399999999999996E-8, 3.4999999999999983E-8, 3.6000000000000005E-8,
    3.6999999999999974E-8, 3.7999999999999996E-8, 3.8999999999999965E-8,
    3.9999999999999988E-8, 4.0999999999999957E-8, 4.1999999999999979E-8, 4.3E-8,
    4.399999999999997E-8, 4.4999999999999993E-8, 4.5999999999999962E-8,
    4.6999999999999984E-8, 4.8000000000000006E-8, 4.8999999999999976E-8, 5.0E-8,
    5.0999999999999967E-8, 5.1999999999999989E-8, 5.2999999999999958E-8,
    5.3999999999999981E-8, 5.5E-8, 5.5999999999999972E-8, 5.6999999999999994E-8,
    5.7999999999999963E-8, 5.8999999999999986E-8, 6.0000000000000008E-8,
    6.0999999999999977E-8, 6.2E-8, 6.2999999999999969E-8, 6.3999999999999991E-8,
    6.499999999999996E-8, 6.5999999999999982E-8, 6.7E-8, 6.7999999999999974E-8,
    6.9E-8, 6.9999999999999965E-8, 7.0999999999999987E-8, 7.2000000000000009E-8,
    7.2999999999999979E-8, 7.4E-8, 7.499999999999997E-8, 7.5999999999999992E-8,
    7.6999999999999962E-8, 7.7999999999999984E-8, 7.9E-8, 7.9999999999999975E-8,
    8.1E-8, 8.1999999999999967E-8, 8.2999999999999989E-8, 8.4000000000000011E-8,
    8.499999999999998E-8, 8.6E-8, 8.6999999999999972E-8, 8.8E-8,
    8.8999999999999963E-8, 8.9999999999999985E-8, 9.1000000000000008E-8,
    9.1999999999999977E-8, 9.3E-8, 9.3999999999999968E-8, 9.499999999999999E-8,
    9.599999999999996E-8, 9.6999999999999982E-8, 9.8E-8, 9.8999999999999973E-8,
    1.0E-7, 1.0099999999999996E-7, 1.0199999999999999E-7, 1.0300000000000001E-7,
    1.0399999999999998E-7, 1.05E-7, 1.0599999999999997E-7, 1.0699999999999999E-7,
    1.0799999999999996E-7, 1.0899999999999998E-7, 1.1E-7, 1.1099999999999997E-7,
    1.12E-7, 1.1299999999999997E-7, 1.1399999999999999E-7, 1.1500000000000001E-7,
    1.1599999999999998E-7, 1.17E-7, 1.1799999999999997E-7, 1.19E-7,
    1.1999999999999996E-7, 1.2099999999999998E-7, 1.22E-7, 1.2299999999999998E-7,
    1.24E-7, 1.2499999999999997E-7, 1.26E-7, 1.27E-7, 1.2799999999999998E-7,
    1.29E-7, 1.2999999999999997E-7, 1.31E-7, 1.3199999999999996E-7,
    1.3299999999999999E-7, 1.34E-7, 1.3499999999999998E-7, 1.36E-7,
    1.3699999999999997E-7, 1.38E-7, 1.3900000000000001E-7, 1.3999999999999998E-7,
    1.41E-7, 1.4199999999999997E-7, 1.43E-7, 1.4399999999999997E-7, 1.45E-7,
    1.46E-7, 1.4699999999999998E-7, 1.48E-7, 1.4899999999999997E-7, 1.5E-7,
    1.5099999999999996E-7, 1.5199999999999998E-7, 1.53E-7, 1.5399999999999998E-7,
    1.55E-7, 1.5599999999999997E-7, 1.57E-7, 1.58E-7, 1.5899999999999998E-7,
    1.6E-7, 1.6099999999999997E-7, 1.62E-7, 1.6299999999999996E-7,
    1.6399999999999999E-7, 1.65E-7, 1.6599999999999998E-7, 1.67E-7,
    1.6799999999999997E-7, 1.69E-7, 1.7000000000000001E-7, 1.7099999999999998E-7,
    1.72E-7, 1.7299999999999997E-7, 1.74E-7, 1.7499999999999997E-7, 1.76E-7,
    1.77E-7, 1.7799999999999998E-7, 1.7899999999999995E-7, 1.8000000000000002E-7,
    1.81E-7, 1.8199999999999996E-7, 1.8300000000000004E-7, 1.84E-7,
    1.8499999999999998E-7, 1.8599999999999994E-7, 1.8700000000000002E-7, 1.88E-7,
    1.8899999999999996E-7, 1.9000000000000003E-7, 1.91E-7, 1.9199999999999997E-7,
    1.9299999999999994E-7, 1.9400000000000002E-7, 1.9499999999999999E-7,
    1.9599999999999996E-7, 1.9700000000000003E-7, 1.98E-7, 1.9899999999999997E-7,
    2.0000000000000004E-7, 2.01E-7, 2.0199999999999998E-7, 2.0299999999999995E-7,
    2.0400000000000003E-7, 2.05E-7, 2.0599999999999997E-7, 2.0700000000000004E-7,
    2.08E-7, 2.0899999999999998E-7, 2.0999999999999995E-7, 2.1100000000000002E-7,
    2.12E-7, 2.1299999999999996E-7, 2.1400000000000004E-7, 2.15E-7,
    2.1599999999999998E-7, 2.1699999999999994E-7, 2.1800000000000002E-7, 2.19E-7,
    2.1999999999999996E-7, 2.2100000000000003E-7, 2.22E-7, 2.2299999999999997E-7,
    2.2399999999999994E-7, 2.2500000000000002E-7, 2.2599999999999999E-7,
    2.2699999999999995E-7, 2.2800000000000003E-7, 2.29E-7, 2.2999999999999997E-7,
    2.3100000000000004E-7, 2.32E-7, 2.3299999999999998E-7, 2.3399999999999995E-7,
    2.3500000000000003E-7, 2.36E-7, 2.3699999999999996E-7, 2.3800000000000004E-7,
    2.39E-7, 2.4E-7, 2.4099999999999995E-7, 2.42E-7, 2.43E-7,
    2.4399999999999996E-7, 2.4500000000000004E-7, 2.46E-7, 2.47E-7,
    2.4799999999999994E-7, 2.49E-7, 2.5E-7, 2.5099999999999996E-7,
    2.5200000000000003E-7, 2.53E-7, 2.5399999999999997E-7, 2.5500000000000005E-7,
    2.56E-7, 2.57E-7, 2.5799999999999995E-7, 2.5900000000000003E-7, 2.6E-7,
    2.6099999999999997E-7, 2.6200000000000004E-7, 2.63E-7, 2.64E-7,
    2.6499999999999995E-7, 2.66E-7, 2.67E-7, 2.6799999999999996E-7,
    2.6900000000000004E-7, 2.7E-7, 2.71E-7, 2.7199999999999995E-7, 2.73E-7,
    2.74E-7, 2.7499999999999996E-7, 2.7600000000000004E-7, 2.77E-7, 2.78E-7,
    2.7899999999999994E-7, 2.8E-7, 2.81E-7, 2.8199999999999996E-7,
    2.8300000000000003E-7, 2.84E-7, 2.8499999999999997E-7, 2.8600000000000005E-7,
    2.87E-7, 2.88E-7, 2.8899999999999995E-7, 2.9000000000000003E-7, 2.91E-7,
    2.9199999999999997E-7, 2.9300000000000004E-7, 2.94E-7, 2.95E-7,
    2.9599999999999995E-7, 2.97E-7, 2.98E-7, 2.9899999999999996E-7,
    3.0000000000000004E-7 };

  short start_idx;
  short tmp_data[58];
  int aoffset;
  char obj_Value[12];
  char filename_Value_data[2920];
  int filename_Value_size[2];
  char name_Value_data[2920];
  int name_Value_size[2];
  static const char cv1[5] = { '_', 'a', 'n', 't', '_' };

  char t0_Value_data[2920];
  int t0_Value_size[2];
  double d_data[464];
  FILE * b_NULL;
  double x_data[464];
  FILE * filestar;
  boolean_T autoflush;
  int iidx_data[464];
  double b_d_data[464];
  double temp_re;
  double temp_im;
  static creal_T dcv2[1082401];
  static double SpotfiSpectrum[1082401];
  static boolean_T isPeak[1082401];
  emxInit_char_T(&s, 2);

  /*  ЗДЕСЬ НУЖНО ЗАМЕНИТЬ 181 на 1801 и 61 на 601 !!!!! */
  cdiff = rt_roundd_snf(seed);
  if (cdiff < 2.147483648E+9) {
    if (cdiff >= -2.147483648E+9) {
      i0 = (int)cdiff;
    } else {
      i0 = MIN_int32_T;
    }
  } else if (cdiff >= 2.147483648E+9) {
    i0 = MAX_int32_T;
  } else {
    i0 = 0;
  }

  b_sprintf(i0, s);
  for (i0 = 0; i0 < 5; i0++) {
    seed_str[i0] = '0';
  }

  if (6 - s->size[1] > 5) {
    i0 = 0;
  } else {
    i0 = 5 - s->size[1];
  }

  loop_ub = s->size[1];
  for (i1 = 0; i1 < loop_ub; i1++) {
    seed_str[i0 + i1] = s->data[i1];
  }

  emxFree_char_T(&s);
  for (i0 = 0; i0 < 26; i0++) {
    filename_Value[i0] = cv0[i0];
  }

  for (i0 = 0; i0 < 5; i0++) {
    filename_Value[i0 + 26] = seed_str[i0];
  }

  filename_Value[31] = '.';
  filename_Value[32] = 't';
  filename_Value[33] = 'x';
  filename_Value[34] = 't';
  fileid = cfopen(filename_Value, "rb");
  b_fseek(fileid);
  cdiff = rt_roundd_snf(b_ftell(fileid));
  if (cdiff < 2.147483648E+9) {
    if (cdiff >= -2.147483648E+9) {
      i0 = (int)cdiff;
    } else {
      i0 = MIN_int32_T;
    }
  } else if (cdiff >= 2.147483648E+9) {
    i0 = MAX_int32_T;
  } else {
    i0 = 0;
  }

  c_fseek(fileid);
  memset(&buffer[0], 0, sizeof(unsigned char) << 21);
  remaining = i0;
  b_index = 1;
  emxInit_real_T(&dataRead, 1);
  emxInit_int32_T(&r0, 2);
  exitg1 = false;
  while ((!exitg1) && (remaining > 0)) {
    if (b_index > MAX_int32_T - remaining) {
      nm1d2 = MAX_int32_T;
    } else {
      nm1d2 = remaining + b_index;
    }

    if (nm1d2 > 2097152) {
      printf("Attempt to read file which is bigger than internal buffer.\n");
      fflush(stdout);
      printf("Current buffer size is %d bytes and file size is %d bytes.\n",
             2097152, i0);
      fflush(stdout);
      exitg1 = true;
    } else {
      b_fread(fileid, remaining, dataRead, &apnd);
      cdiff = rt_roundd_snf((double)b_index + apnd);
      if (cdiff < 2.147483648E+9) {
        if (cdiff >= -2.147483648E+9) {
          nm1d2 = (int)cdiff;
        } else {
          nm1d2 = MIN_int32_T;
        }
      } else if (cdiff >= 2.147483648E+9) {
        nm1d2 = MAX_int32_T;
      } else {
        nm1d2 = 0;
      }

      if (nm1d2 < -2147483647) {
        nm1d2 = MIN_int32_T;
      } else {
        nm1d2--;
      }

      if (b_index > nm1d2) {
        i1 = 0;
        nm1d2 = 0;
      } else {
        i1 = b_index - 1;
      }

      i2 = r0->size[0] * r0->size[1];
      r0->size[0] = 1;
      loop_ub = nm1d2 - i1;
      r0->size[1] = loop_ub;
      emxEnsureCapacity_int32_T(r0, i2);
      for (i2 = 0; i2 < loop_ub; i2++) {
        r0->data[i2] = i1 + i2;
      }

      loop_ub = r0->size[0] * r0->size[1];
      for (i1 = 0; i1 < loop_ub; i1++) {
        cdiff = rt_roundd_snf(dataRead->data[i1]);
        if (cdiff < 256.0) {
          if (cdiff >= 0.0) {
            u0 = (unsigned char)cdiff;
          } else {
            u0 = 0U;
          }
        } else if (cdiff >= 256.0) {
          u0 = MAX_uint8_T;
        } else {
          u0 = 0U;
        }

        buffer[r0->data[i1]] = u0;
      }

      cdiff = rt_roundd_snf(apnd);
      if (cdiff < 2.147483648E+9) {
        if (cdiff >= -2.147483648E+9) {
          nm1d2 = (int)cdiff;
        } else {
          nm1d2 = MIN_int32_T;
        }
      } else if (cdiff >= 2.147483648E+9) {
        nm1d2 = MAX_int32_T;
      } else {
        nm1d2 = 0;
      }

      if (nm1d2 == 0) {
        exitg1 = true;
      } else {
        /*  Did something went wrong when reading? */
        if (nm1d2 < 0) {
          printf("Could not read from file: %d.\n", nm1d2);
          fflush(stdout);
          exitg1 = true;
        } else {
          /*  Update state variables */
          remaining -= nm1d2;
          if ((b_index < 0) && (nm1d2 < MIN_int32_T - b_index)) {
            b_index = MIN_int32_T;
          } else if ((b_index > 0) && (nm1d2 > MAX_int32_T - b_index)) {
            b_index = MAX_int32_T;
          } else {
            b_index += nm1d2;
          }
        }
      }
    }
  }

  emxFree_int32_T(&r0);
  emxFree_real_T(&dataRead);
  emxInit_uint8_T(&b_buffer, 2);

  /*  Close file */
  b_fclose(fileid);
  i0 = b_buffer->size[0] * b_buffer->size[1];
  b_buffer->size[0] = 1;
  b_buffer->size[1] = b_index;
  emxEnsureCapacity_uint8_T(b_buffer, i0);
  for (i0 = 0; i0 < b_index; i0++) {
    b_buffer->data[i0] = buffer[i0];
  }

  emxInit_char_T(&str, 2);
  b_char(b_buffer, str);
  emxFree_uint8_T(&b_buffer);
  i0 = str->size[0] * str->size[1];
  if (1 > b_index - 1) {
    str->size[1] = 0;
  } else {
    str->size[1] = b_index - 1;
  }

  emxEnsureCapacity_char_T(str, i0);
  k = 1;
  emxInit_char_T(&b_str, 2);
  for (i = 0; i < 28800; i++) {
    for (j = k - 1; str->data[j] != ' '; j++) {
    }

    if (k > j) {
      i0 = 0;
      i1 = 0;
    } else {
      i0 = k - 1;
      i1 = j;
    }

    i2 = b_str->size[0] * b_str->size[1];
    b_str->size[0] = 1;
    loop_ub = i1 - i0;
    b_str->size[1] = loop_ub;
    emxEnsureCapacity_char_T(b_str, i2);
    for (i1 = 0; i1 < loop_ub; i1++) {
      b_str->data[i1] = str->data[i0 + i1];
    }

    y[i] = str2double(b_str);
    k = j + 2;
  }

  emxFree_char_T(&b_str);
  emxFree_char_T(&str);

  /*  reading completed */
  end = time(NULL);
  printf("reading completed: %s\n", ctime(&end));

  /*  packetNum = [10]; */
  /*  packetPerSpectrum = [1]; */
  /*  antennasNum = [4]; */
  /*  bandwidth = [20]; */
  /*  subcarrierDecimationUsed = [1]; */
  /*  backwardSmoothing = [0]; */
  /*  useSmothing = [0]; */
  emxInit_creal_T(&matrixCSI, 3);
  emxInit_creal_T(&smoothedMatrixCSI, 3);
  emxInit_creal_T(&D, 3);
  emxInit_creal_T(&De, 2);
  emxInit_creal_T(&tmp, 2);
  emxInit_creal_T(&conjCsiTracePerPacket, 3);
  emxInit_creal_T(&steeringVector, 2);
  emxInit_real_T(&nsDelayAngleSpotfiEstimated, 2);
  emxInit_creal_T(&mat, 2);
  emxInit_creal_T(&Rxx, 2);
  emxInit_creal_T(&Pn, 2);
  emxInit_boolean_T(&isStrongEnough, 1);
  emxInit_real_T(&newEstimation, 2);
  emxInit_creal_T(&Utmp, 2);
  emxInit_creal_T(&r1, 2);
  emxInit_boolean_T(&r2, 2);
  emxInit_boolean_T(&r3, 2);
  emxInit_int32_T(&r4, 1);
  emxInit_int32_T(&r5, 2);
  emxInit_creal_T(&b, 2);
  emxInit_creal_T(&b_y, 2);
  emxInit_int32_T(&ii, 1);
  emxInit_int16_T(&vk, 1);
  emxInit_real_T(&varargin_1, 1);
  emxInit_creal_T(&r6, 2);
  emxInit_creal_T(&r7, 2);
  emxInit_creal_T(&r8, 2);
  emxInit_real_T(&r9, 2);
  emxInit_creal_T(&b_steeringVector, 2);
  emxInit_real_T(&b_newEstimation, 2);
  emxInit_real_T(&b_nsDelayAngleSpotfiEstimated, 2);
  for (ant = 0; ant < 2; ant++) {
    b_ant = 8 + -4 * ant;
    for (p = 0; p < 2; p++) {
      b_p = 30 + -20 * p;
      for (perSpec = 0; perSpec < 2; perSpec++) {
        numberOfSpectrums = (int)floor((double)b_p / (2.0 - (double)perSpec));
        loop_ub_tmp = numberOfSpectrums * (2 - perSpec);
        for (band = 0; band < 2; band++) {
          b_band = 40 + -20 * band;
          for (dec = 0; dec < 2; dec++) {
            switch (b_band) {
             case 20:
              subCarrIndEnd = 56;
              if (dec != 0) {
                subCarrIndStep = 2;
              } else {
                subCarrIndStep = 1;
              }
              break;

             case 40:
              subCarrIndEnd = 117;
              if (dec != 0) {
                subCarrIndStep = 4;
              } else {
                subCarrIndStep = 1;
              }
              break;
            }

            nm1d2 = div_s32_floor(subCarrIndEnd - 1, subCarrIndStep);
            subCarrInd_size_idx_1 = nm1d2 + 1;
            varargin_2 = subCarrInd_size_idx_1 + 1;
            numberOfSubcarrierSubsets = (int)floor((double)subCarrInd_size_idx_1
              / 2.0);
            loop_ub = subCarrInd_size_idx_1 * b_ant * loop_ub_tmp;
            for (i0 = 0; i0 <= nm1d2; i0++) {
              subCarrInd_data[i0] = (signed char)(1 + (signed char)
                (subCarrIndStep * (signed char)i0));
            }

            for (smoothing = 0; smoothing < 2; smoothing++) {
              if (1 - smoothing != 0) {
                switch (b_ant) {
                 case 8:
                  subarrayNum = 2;
                  break;

                 case 4:
                  subarrayNum = 1;
                  break;
                }
              } else {
                subarrayNum = 0;
              }

              numberOfAntennaInSubset = b_ant - subarrayNum;
              a = ((double)numberOfAntennaInSubset - 1.0) / 2.0;
              b_b = -((double)numberOfAntennaInSubset - 1.0) / 2.0;
              for (backw = 0; backw < 2; backw++) {
                /*  number fo subset of subcarriers chosen for smoothing music */
                i0 = matrixCSI->size[0] * matrixCSI->size[1] * matrixCSI->size[2];
                matrixCSI->size[0] = subCarrInd_size_idx_1;
                matrixCSI->size[1] = b_ant;
                matrixCSI->size[2] = loop_ub_tmp;
                emxEnsureCapacity_creal_T(matrixCSI, i0);
                for (i0 = 0; i0 < loop_ub_tmp; i0++) {
                  for (i1 = 0; i1 < b_ant; i1++) {
                    for (i2 = 0; i2 < subCarrInd_size_idx_1; i2++) {
                      matrixCSI->data[(i2 + matrixCSI->size[0] * i1) +
                        matrixCSI->size[0] * matrixCSI->size[1] * i0] = y
                        [((subCarrInd_data[i2] + 120 * i1) + 960 * i0) - 1];
                    }
                  }
                }

                i0 = smoothedMatrixCSI->size[0] * smoothedMatrixCSI->size[1] *
                  smoothedMatrixCSI->size[2];
                smoothedMatrixCSI->size[0] = subCarrInd_size_idx_1;
                smoothedMatrixCSI->size[1] = b_ant;
                smoothedMatrixCSI->size[2] = loop_ub_tmp;
                emxEnsureCapacity_creal_T(smoothedMatrixCSI, i0);
                for (i0 = 0; i0 < loop_ub; i0++) {
                  smoothedMatrixCSI->data[i0] = matrixCSI->data[i0];
                }

                if (iv0[backw] != 0) {
                  i0 = ((b_ant - numberOfAntennaInSubset) + 1) *
                    ((subCarrInd_size_idx_1 - numberOfSubcarrierSubsets) + 1);
                  i1 = matrixCSI->size[0] * matrixCSI->size[1] * matrixCSI->
                    size[2];
                  matrixCSI->size[0] = numberOfAntennaInSubset *
                    numberOfSubcarrierSubsets;
                  i2 = (i0 << 1) * (2 - perSpec);
                  matrixCSI->size[1] = i2;
                  matrixCSI->size[2] = numberOfSpectrums;
                  emxEnsureCapacity_creal_T(matrixCSI, i1);
                  b_loop_ub = numberOfAntennaInSubset *
                    numberOfSubcarrierSubsets * i2 * numberOfSpectrums;
                  for (i1 = 0; i1 < b_loop_ub; i1++) {
                    matrixCSI->data[i1].re = 0.0;
                    matrixCSI->data[i1].im = 0.0;
                  }

                  i1 = 2 - perSpec;
                  b_loop_ub = numberOfSubcarrierSubsets * (varargin_2 -
                    numberOfSubcarrierSubsets) * b_ant;
                  if (numberOfSubcarrierSubsets > subCarrInd_size_idx_1) {
                    i2 = 0;
                    i3 = -1;
                  } else {
                    i2 = numberOfSubcarrierSubsets - 1;
                    i3 = varargin_2 - 2;
                  }

                  b_loop_ub_tmp = i3 - i2;
                  c_loop_ub = numberOfAntennaInSubset *
                    numberOfSubcarrierSubsets * i0;
                  d_loop_ub = numberOfSubcarrierSubsets * (((b_ant -
                    numberOfAntennaInSubset) + 1) * (varargin_2 -
                    numberOfSubcarrierSubsets));
                  i3 = b_ant - numberOfAntennaInSubset;
                  e_loop_ub = (signed char)numberOfSubcarrierSubsets - 1;
                  b_index = (signed char)numberOfSubcarrierSubsets;
                  for (i4 = 0; i4 <= e_loop_ub; i4++) {
                    y_data[i4] = (signed char)(1 + i4);
                  }

                  for (t = 0; t < numberOfSpectrums; t++) {
                    for (b_s = 0; b_s < i1; b_s++) {
                      e_loop_ub = smoothedMatrixCSI->size[0];
                      nm1d2 = smoothedMatrixCSI->size[1];
                      remaining = t * (2 - perSpec) + b_s;
                      for (i4 = 0; i4 < nm1d2; i4++) {
                        for (i5 = 0; i5 < e_loop_ub; i5++) {
                          csiFromEachPacket_data[i5 + e_loop_ub * i4] =
                            smoothedMatrixCSI->data[(i5 +
                            smoothedMatrixCSI->size[0] * i4) +
                            smoothedMatrixCSI->size[0] * smoothedMatrixCSI->
                            size[1] * remaining];
                        }
                      }

                      i4 = D->size[0] * D->size[1] * D->size[2];
                      D->size[0] = numberOfSubcarrierSubsets;
                      D->size[1] = varargin_2 - numberOfSubcarrierSubsets;
                      D->size[2] = b_ant;
                      emxEnsureCapacity_creal_T(D, i4);
                      for (i4 = 0; i4 < b_loop_ub; i4++) {
                        D->data[i4].re = 0.0;
                        D->data[i4].im = 0.0;
                      }

                      for (m = 0; m < b_ant; m++) {
                        /*  mth antenna */
                        csiFromEachPacket_size[0] = numberOfSubcarrierSubsets;
                        for (i4 = 0; i4 < numberOfSubcarrierSubsets; i4++) {
                          b_csiFromEachPacket_data[i4] =
                            csiFromEachPacket_data[i4 + e_loop_ub * m];
                        }

                        b_csiFromEachPacket_size[0] = b_loop_ub_tmp + 1;
                        for (i4 = 0; i4 <= b_loop_ub_tmp; i4++) {
                          c_csiFromEachPacket_data[i4] = csiFromEachPacket_data
                            [(i2 + i4) + e_loop_ub * m];
                        }

                        hankel(b_csiFromEachPacket_data, csiFromEachPacket_size,
                               c_csiFromEachPacket_data,
                               b_csiFromEachPacket_size, r8);
                        nm1d2 = r8->size[1];
                        for (i4 = 0; i4 < nm1d2; i4++) {
                          remaining = r8->size[0];
                          for (i5 = 0; i5 < remaining; i5++) {
                            D->data[(i5 + D->size[0] * i4) + D->size[0] *
                              D->size[1] * m] = r8->data[i5 + r8->size[0] * i4];
                          }
                        }
                      }

                      i4 = De->size[0] * De->size[1];
                      De->size[0] = numberOfAntennaInSubset *
                        numberOfSubcarrierSubsets;
                      De->size[1] = i0;
                      emxEnsureCapacity_creal_T(De, i4);
                      for (i4 = 0; i4 < c_loop_ub; i4++) {
                        De->data[i4].re = 0.0;
                        De->data[i4].im = 0.0;
                      }

                      for (boffset = 0; boffset < numberOfAntennaInSubset;
                           boffset++) {
                        i4 = tmp->size[0] * tmp->size[1];
                        tmp->size[0] = numberOfSubcarrierSubsets;
                        tmp->size[1] = ((b_ant - numberOfAntennaInSubset) + 1) *
                          (varargin_2 - numberOfSubcarrierSubsets);
                        emxEnsureCapacity_creal_T(tmp, i4);
                        for (i4 = 0; i4 < d_loop_ub; i4++) {
                          tmp->data[i4].re = 0.0;
                          tmp->data[i4].im = 0.0;
                        }

                        for (j = 0; j <= i3; j++) {
                          i4 = j * (varargin_2 - numberOfSubcarrierSubsets) + 1;
                          if (i4 > (1 + j) * (varargin_2 -
                                              numberOfSubcarrierSubsets)) {
                            i4 = 0;
                          } else {
                            i4--;
                          }

                          e_loop_ub = D->size[0];
                          nm1d2 = D->size[1];
                          aoffset = boffset + j;
                          i5 = r1->size[0] * r1->size[1];
                          r1->size[0] = e_loop_ub;
                          r1->size[1] = nm1d2;
                          emxEnsureCapacity_creal_T(r1, i5);
                          for (i5 = 0; i5 < nm1d2; i5++) {
                            for (remaining = 0; remaining < e_loop_ub; remaining
                                 ++) {
                              r1->data[remaining + r1->size[0] * i5] = D->data
                                [(remaining + D->size[0] * i5) + D->size[0] *
                                D->size[1] * aoffset];
                            }
                          }

                          e_loop_ub = r1->size[1];
                          for (i5 = 0; i5 < e_loop_ub; i5++) {
                            nm1d2 = r1->size[0];
                            for (remaining = 0; remaining < nm1d2; remaining++)
                            {
                              tmp->data[remaining + tmp->size[0] * (i4 + i5)] =
                                r1->data[remaining + r1->size[0] * i5];
                            }
                          }
                        }

                        start_idx = (short)(boffset * (short)
                                            numberOfSubcarrierSubsets);
                        for (i4 = 0; i4 < b_index; i4++) {
                          tmp_data[i4] = (short)((short)(y_data[i4] + start_idx)
                            - 1);
                        }

                        e_loop_ub = tmp->size[1];
                        for (i4 = 0; i4 < e_loop_ub; i4++) {
                          nm1d2 = tmp->size[0];
                          for (i5 = 0; i5 < nm1d2; i5++) {
                            De->data[tmp_data[i5] + De->size[0] * i4] =
                              tmp->data[i5 + tmp->size[0] * i4];
                          }
                        }
                      }

                      i4 = ((b_s * i0) << 1) + 1;
                      if (i4 > (((1 + b_s) * i0) << 1) - i0) {
                        i4 = 0;
                      } else {
                        i4--;
                      }

                      e_loop_ub = De->size[1];
                      for (i5 = 0; i5 < e_loop_ub; i5++) {
                        nm1d2 = De->size[0];
                        for (remaining = 0; remaining < nm1d2; remaining++) {
                          matrixCSI->data[(remaining + matrixCSI->size[0] * (i4
                            + i5)) + matrixCSI->size[0] * matrixCSI->size[1] * t]
                            = De->data[remaining + De->size[0] * i5];
                        }
                      }
                    }
                  }

                  i1 = smoothedMatrixCSI->size[0];
                  i2 = smoothedMatrixCSI->size[1];
                  b_loop_ub = smoothedMatrixCSI->size[2];
                  i3 = conjCsiTracePerPacket->size[0] *
                    conjCsiTracePerPacket->size[1] * conjCsiTracePerPacket->
                    size[2];
                  c_loop_ub = div_s32_floor(1 - i1, -1);
                  conjCsiTracePerPacket->size[0] = c_loop_ub + 1;
                  d_loop_ub = div_s32_floor(1 - i2, -1);
                  conjCsiTracePerPacket->size[1] = d_loop_ub + 1;
                  conjCsiTracePerPacket->size[2] = b_loop_ub;
                  emxEnsureCapacity_creal_T(conjCsiTracePerPacket, i3);
                  for (i3 = 0; i3 < b_loop_ub; i3++) {
                    for (i4 = 0; i4 <= d_loop_ub; i4++) {
                      for (i5 = 0; i5 <= c_loop_ub; i5++) {
                        conjCsiTracePerPacket->data[(i5 +
                          conjCsiTracePerPacket->size[0] * i4) +
                          conjCsiTracePerPacket->size[0] *
                          conjCsiTracePerPacket->size[1] * i3].re =
                          smoothedMatrixCSI->data[(((i1 - i5) +
                          smoothedMatrixCSI->size[0] * ((i2 - i4) - 1)) +
                          smoothedMatrixCSI->size[0] * smoothedMatrixCSI->size[1]
                          * i3) - 1].re;
                        conjCsiTracePerPacket->data[(i5 +
                          conjCsiTracePerPacket->size[0] * i4) +
                          conjCsiTracePerPacket->size[0] *
                          conjCsiTracePerPacket->size[1] * i3].im =
                          -smoothedMatrixCSI->data[(((i1 - i5) +
                          smoothedMatrixCSI->size[0] * ((i2 - i4) - 1)) +
                          smoothedMatrixCSI->size[0] * smoothedMatrixCSI->size[1]
                          * i3) - 1].im;
                      }
                    }
                  }

                  i1 = 2 - perSpec;
                  b_loop_ub = numberOfSubcarrierSubsets * (varargin_2 -
                    numberOfSubcarrierSubsets) * b_ant;
                  if (numberOfSubcarrierSubsets > subCarrInd_size_idx_1) {
                    i2 = 0;
                    i3 = -1;
                  } else {
                    i2 = numberOfSubcarrierSubsets - 1;
                    i3 = varargin_2 - 2;
                  }

                  b_loop_ub_tmp = i3 - i2;
                  c_loop_ub = numberOfAntennaInSubset *
                    numberOfSubcarrierSubsets * (((b_ant -
                    numberOfAntennaInSubset) + 1) * (varargin_2 -
                    numberOfSubcarrierSubsets));
                  d_loop_ub = numberOfSubcarrierSubsets * (((b_ant -
                    numberOfAntennaInSubset) + 1) * (varargin_2 -
                    numberOfSubcarrierSubsets));
                  i3 = b_ant - numberOfAntennaInSubset;
                  e_loop_ub = (signed char)numberOfSubcarrierSubsets - 1;
                  b_index = (signed char)numberOfSubcarrierSubsets;
                  for (i4 = 0; i4 <= e_loop_ub; i4++) {
                    y_data[i4] = (signed char)(1 + i4);
                  }

                  for (t = 0; t < numberOfSpectrums; t++) {
                    for (b_s = 0; b_s < i1; b_s++) {
                      e_loop_ub = conjCsiTracePerPacket->size[0];
                      nm1d2 = conjCsiTracePerPacket->size[1];
                      remaining = t * (2 - perSpec) + b_s;
                      for (i4 = 0; i4 < nm1d2; i4++) {
                        for (i5 = 0; i5 < e_loop_ub; i5++) {
                          csiFromEachPacket_data[i5 + e_loop_ub * i4] =
                            conjCsiTracePerPacket->data[(i5 +
                            conjCsiTracePerPacket->size[0] * i4) +
                            conjCsiTracePerPacket->size[0] *
                            conjCsiTracePerPacket->size[1] * remaining];
                        }
                      }

                      i4 = D->size[0] * D->size[1] * D->size[2];
                      D->size[0] = numberOfSubcarrierSubsets;
                      D->size[1] = varargin_2 - numberOfSubcarrierSubsets;
                      D->size[2] = b_ant;
                      emxEnsureCapacity_creal_T(D, i4);
                      for (i4 = 0; i4 < b_loop_ub; i4++) {
                        D->data[i4].re = 0.0;
                        D->data[i4].im = 0.0;
                      }

                      for (m = 0; m < b_ant; m++) {
                        /*  mth antenna */
                        csiFromEachPacket_size[0] = numberOfSubcarrierSubsets;
                        for (i4 = 0; i4 < numberOfSubcarrierSubsets; i4++) {
                          b_csiFromEachPacket_data[i4] =
                            csiFromEachPacket_data[i4 + e_loop_ub * m];
                        }

                        b_csiFromEachPacket_size[0] = b_loop_ub_tmp + 1;
                        for (i4 = 0; i4 <= b_loop_ub_tmp; i4++) {
                          c_csiFromEachPacket_data[i4] = csiFromEachPacket_data
                            [(i2 + i4) + e_loop_ub * m];
                        }

                        hankel(b_csiFromEachPacket_data, csiFromEachPacket_size,
                               c_csiFromEachPacket_data,
                               b_csiFromEachPacket_size, r8);
                        nm1d2 = r8->size[1];
                        for (i4 = 0; i4 < nm1d2; i4++) {
                          remaining = r8->size[0];
                          for (i5 = 0; i5 < remaining; i5++) {
                            D->data[(i5 + D->size[0] * i4) + D->size[0] *
                              D->size[1] * m] = r8->data[i5 + r8->size[0] * i4];
                          }
                        }
                      }

                      i4 = De->size[0] * De->size[1];
                      De->size[0] = numberOfAntennaInSubset *
                        numberOfSubcarrierSubsets;
                      De->size[1] = ((b_ant - numberOfAntennaInSubset) + 1) *
                        (varargin_2 - numberOfSubcarrierSubsets);
                      emxEnsureCapacity_creal_T(De, i4);
                      for (i4 = 0; i4 < c_loop_ub; i4++) {
                        De->data[i4].re = 0.0;
                        De->data[i4].im = 0.0;
                      }

                      for (boffset = 0; boffset < numberOfAntennaInSubset;
                           boffset++) {
                        i4 = tmp->size[0] * tmp->size[1];
                        tmp->size[0] = numberOfSubcarrierSubsets;
                        tmp->size[1] = ((b_ant - numberOfAntennaInSubset) + 1) *
                          (varargin_2 - numberOfSubcarrierSubsets);
                        emxEnsureCapacity_creal_T(tmp, i4);
                        for (i4 = 0; i4 < d_loop_ub; i4++) {
                          tmp->data[i4].re = 0.0;
                          tmp->data[i4].im = 0.0;
                        }

                        for (j = 0; j <= i3; j++) {
                          i4 = j * (varargin_2 - numberOfSubcarrierSubsets) + 1;
                          if (i4 > (1 + j) * (varargin_2 -
                                              numberOfSubcarrierSubsets)) {
                            i4 = 0;
                          } else {
                            i4--;
                          }

                          e_loop_ub = D->size[0];
                          nm1d2 = D->size[1];
                          aoffset = boffset + j;
                          i5 = r1->size[0] * r1->size[1];
                          r1->size[0] = e_loop_ub;
                          r1->size[1] = nm1d2;
                          emxEnsureCapacity_creal_T(r1, i5);
                          for (i5 = 0; i5 < nm1d2; i5++) {
                            for (remaining = 0; remaining < e_loop_ub; remaining
                                 ++) {
                              r1->data[remaining + r1->size[0] * i5] = D->data
                                [(remaining + D->size[0] * i5) + D->size[0] *
                                D->size[1] * aoffset];
                            }
                          }

                          e_loop_ub = r1->size[1];
                          for (i5 = 0; i5 < e_loop_ub; i5++) {
                            nm1d2 = r1->size[0];
                            for (remaining = 0; remaining < nm1d2; remaining++)
                            {
                              tmp->data[remaining + tmp->size[0] * (i4 + i5)] =
                                r1->data[remaining + r1->size[0] * i5];
                            }
                          }
                        }

                        start_idx = (short)(boffset * (short)
                                            numberOfSubcarrierSubsets);
                        for (i4 = 0; i4 < b_index; i4++) {
                          tmp_data[i4] = (short)((short)(y_data[i4] + start_idx)
                            - 1);
                        }

                        e_loop_ub = tmp->size[1];
                        for (i4 = 0; i4 < e_loop_ub; i4++) {
                          nm1d2 = tmp->size[0];
                          for (i5 = 0; i5 < nm1d2; i5++) {
                            De->data[tmp_data[i5] + De->size[0] * i4] =
                              tmp->data[i5 + tmp->size[0] * i4];
                          }
                        }
                      }

                      i4 = (((b_s * i0) << 1) + i0) + 1;
                      if (i4 > (((1 + b_s) * i0) << 1)) {
                        i4 = 0;
                      } else {
                        i4--;
                      }

                      e_loop_ub = De->size[1];
                      for (i5 = 0; i5 < e_loop_ub; i5++) {
                        nm1d2 = De->size[0];
                        for (remaining = 0; remaining < nm1d2; remaining++) {
                          matrixCSI->data[(remaining + matrixCSI->size[0] * (i4
                            + i5)) + matrixCSI->size[0] * matrixCSI->size[1] * t]
                            = De->data[remaining + De->size[0] * i5];
                        }
                      }
                    }
                  }
                } else {
                  numberOfSourses = b_ant - numberOfAntennaInSubset;
                  remaining = numberOfSourses + 1;
                  k = remaining * ((subCarrInd_size_idx_1 -
                                    numberOfSubcarrierSubsets) + 1);
                  i0 = matrixCSI->size[0] * matrixCSI->size[1] * matrixCSI->
                    size[2];
                  i1 = numberOfAntennaInSubset * numberOfSubcarrierSubsets;
                  matrixCSI->size[0] = i1;
                  i2 = k * (2 - perSpec);
                  matrixCSI->size[1] = i2;
                  matrixCSI->size[2] = numberOfSpectrums;
                  emxEnsureCapacity_creal_T(matrixCSI, i0);
                  b_loop_ub = i1 * i2 * numberOfSpectrums;
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    matrixCSI->data[i0].re = 0.0;
                    matrixCSI->data[i0].im = 0.0;
                  }

                  i0 = 2 - perSpec;
                  b_loop_ub_tmp = varargin_2 - numberOfSubcarrierSubsets;
                  i = numberOfSubcarrierSubsets * b_loop_ub_tmp * b_ant;
                  if (numberOfSubcarrierSubsets > subCarrInd_size_idx_1) {
                    i2 = 0;
                    i3 = -1;
                  } else {
                    i2 = numberOfSubcarrierSubsets - 1;
                    i3 = varargin_2 - 2;
                  }

                  c_loop_ub_tmp = i3 - i2;
                  d_loop_ub_tmp = i1 * k;
                  b_index = remaining * b_loop_ub_tmp;
                  nm1d2 = numberOfSubcarrierSubsets * b_index;
                  remaining = (signed char)numberOfSubcarrierSubsets - 1;
                  b_loop_ub = (signed char)numberOfSubcarrierSubsets;
                  for (i3 = 0; i3 <= remaining; i3++) {
                    y_data[i3] = (signed char)(1 + i3);
                  }

                  for (t = 0; t < numberOfSpectrums; t++) {
                    for (b_s = 0; b_s < i0; b_s++) {
                      c_loop_ub = smoothedMatrixCSI->size[0];
                      d_loop_ub = smoothedMatrixCSI->size[1];
                      remaining = t * (2 - perSpec) + b_s;
                      for (i3 = 0; i3 < d_loop_ub; i3++) {
                        for (i4 = 0; i4 < c_loop_ub; i4++) {
                          csiFromEachPacket_data[i4 + c_loop_ub * i3] =
                            smoothedMatrixCSI->data[(i4 +
                            smoothedMatrixCSI->size[0] * i3) +
                            smoothedMatrixCSI->size[0] * smoothedMatrixCSI->
                            size[1] * remaining];
                        }
                      }

                      i3 = D->size[0] * D->size[1] * D->size[2];
                      D->size[0] = numberOfSubcarrierSubsets;
                      D->size[1] = b_loop_ub_tmp;
                      D->size[2] = b_ant;
                      emxEnsureCapacity_creal_T(D, i3);
                      for (i3 = 0; i3 < i; i3++) {
                        D->data[i3].re = 0.0;
                        D->data[i3].im = 0.0;
                      }

                      for (m = 0; m < b_ant; m++) {
                        /*  mth antenna */
                        csiFromEachPacket_size[0] = numberOfSubcarrierSubsets;
                        for (i3 = 0; i3 < numberOfSubcarrierSubsets; i3++) {
                          b_csiFromEachPacket_data[i3] =
                            csiFromEachPacket_data[i3 + c_loop_ub * m];
                        }

                        b_csiFromEachPacket_size[0] = c_loop_ub_tmp + 1;
                        for (i3 = 0; i3 <= c_loop_ub_tmp; i3++) {
                          c_csiFromEachPacket_data[i3] = csiFromEachPacket_data
                            [(i2 + i3) + c_loop_ub * m];
                        }

                        hankel(b_csiFromEachPacket_data, csiFromEachPacket_size,
                               c_csiFromEachPacket_data,
                               b_csiFromEachPacket_size, r8);
                        d_loop_ub = r8->size[1];
                        for (i3 = 0; i3 < d_loop_ub; i3++) {
                          e_loop_ub = r8->size[0];
                          for (i4 = 0; i4 < e_loop_ub; i4++) {
                            D->data[(i4 + D->size[0] * i3) + D->size[0] *
                              D->size[1] * m] = r8->data[i4 + r8->size[0] * i3];
                          }
                        }
                      }

                      i3 = De->size[0] * De->size[1];
                      De->size[0] = i1;
                      De->size[1] = k;
                      emxEnsureCapacity_creal_T(De, i3);
                      for (i3 = 0; i3 < d_loop_ub_tmp; i3++) {
                        De->data[i3].re = 0.0;
                        De->data[i3].im = 0.0;
                      }

                      for (boffset = 0; boffset < numberOfAntennaInSubset;
                           boffset++) {
                        i3 = tmp->size[0] * tmp->size[1];
                        tmp->size[0] = numberOfSubcarrierSubsets;
                        tmp->size[1] = b_index;
                        emxEnsureCapacity_creal_T(tmp, i3);
                        for (i3 = 0; i3 < nm1d2; i3++) {
                          tmp->data[i3].re = 0.0;
                          tmp->data[i3].im = 0.0;
                        }

                        for (j = 0; j <= numberOfSourses; j++) {
                          i3 = j * b_loop_ub_tmp + 1;
                          if (i3 > (1 + j) * (varargin_2 -
                                              numberOfSubcarrierSubsets)) {
                            i3 = 0;
                          } else {
                            i3--;
                          }

                          c_loop_ub = D->size[0];
                          d_loop_ub = D->size[1];
                          aoffset = boffset + j;
                          i4 = r1->size[0] * r1->size[1];
                          r1->size[0] = c_loop_ub;
                          r1->size[1] = d_loop_ub;
                          emxEnsureCapacity_creal_T(r1, i4);
                          for (i4 = 0; i4 < d_loop_ub; i4++) {
                            for (i5 = 0; i5 < c_loop_ub; i5++) {
                              r1->data[i5 + r1->size[0] * i4] = D->data[(i5 +
                                D->size[0] * i4) + D->size[0] * D->size[1] *
                                aoffset];
                            }
                          }

                          c_loop_ub = r1->size[1];
                          for (i4 = 0; i4 < c_loop_ub; i4++) {
                            d_loop_ub = r1->size[0];
                            for (i5 = 0; i5 < d_loop_ub; i5++) {
                              tmp->data[i5 + tmp->size[0] * (i3 + i4)] =
                                r1->data[i5 + r1->size[0] * i4];
                            }
                          }
                        }

                        start_idx = (short)(boffset * (short)
                                            numberOfSubcarrierSubsets);
                        for (i3 = 0; i3 < b_loop_ub; i3++) {
                          tmp_data[i3] = (short)((short)(y_data[i3] + start_idx)
                            - 1);
                        }

                        c_loop_ub = tmp->size[1];
                        for (i3 = 0; i3 < c_loop_ub; i3++) {
                          d_loop_ub = tmp->size[0];
                          for (i4 = 0; i4 < d_loop_ub; i4++) {
                            De->data[tmp_data[i4] + De->size[0] * i3] =
                              tmp->data[i4 + tmp->size[0] * i3];
                          }
                        }
                      }

                      i3 = b_s * k + 1;
                      if (i3 > (1 + b_s) * k) {
                        i3 = 0;
                      } else {
                        i3--;
                      }

                      c_loop_ub = De->size[1];
                      for (i4 = 0; i4 < c_loop_ub; i4++) {
                        d_loop_ub = De->size[0];
                        for (i5 = 0; i5 < d_loop_ub; i5++) {
                          matrixCSI->data[(i5 + matrixCSI->size[0] * (i3 + i4))
                            + matrixCSI->size[0] * matrixCSI->size[1] * t] =
                            De->data[i5 + De->size[0] * i4];
                        }
                      }
                    }
                  }
                }

                /*  smoothing completed */
  		end = time(NULL);
  		printf("smoothing completed: %s\n", ctime(&end));

                if (floor(a) == a) {
                  remaining = (int)floor(-(b_b - a));
                  b_index = remaining + 1;
                  for (i0 = 0; i0 <= remaining; i0++) {
                    b_y_data[i0] = a - (double)i0;
                  }
                } else {
                  b_index = (int)floor((b_b - a) / -1.0 + 0.5);
                  apnd = a + -(double)b_index;
                  cdiff = b_b - apnd;
                  if (fabs(cdiff) < 4.4408920985006262E-16 * fmax(a, fabs(b_b)))
                  {
                    b_index++;
                    apnd = b_b;
                  } else if (cdiff > 0.0) {
                    apnd = a + -((double)b_index - 1.0);
                  } else {
                    b_index++;
                  }

                  b_y_data[0] = a;
                  if (b_index > 1) {
                    b_y_data[b_index - 1] = apnd;
                    nm1d2 = (b_index - 1) / 2;
                    for (k = 0; k <= nm1d2 - 2; k++) {
                      b_y_data[1 + k] = a + -(1.0 + (double)k);
                      b_y_data[(b_index - k) - 2] = apnd - (-(1.0 + (double)k));
                    }

                    if (nm1d2 << 1 == b_index - 1) {
                      b_y_data[nm1d2] = (a + apnd) / 2.0;
                    } else {
                      b_y_data[nm1d2] = a + -(double)nm1d2;
                      b_y_data[nm1d2 + 1] = apnd - (-(double)nm1d2);
                    }
                  }
                }

                memcpy(&dv0[0], &dv1[0], 1801U * sizeof(double));
                b_sind(dv0);
                for (i0 = 0; i0 < 1801; i0++) {
                  dcv0[i0].re = 0.5 * dv0[i0];
                  dcv0[i0].im = 0.0;
                }

                i0 = r6->size[0] * r6->size[1];
                r6->size[0] = b_index;
                r6->size[1] = 1801;
                emxEnsureCapacity_creal_T(r6, i0);
                for (i0 = 0; i0 < b_index; i0++) {
                  for (i1 = 0; i1 < 1801; i1++) {
                    apnd = b_y_data[i0] * -0.0;
                    cdiff = b_y_data[i0] * -6.2831853071795862;
                    r6->data[i0 + r6->size[0] * i1].re = apnd * dcv0[i1].re -
                      cdiff * dcv0[i1].im;
                    r6->data[i0 + r6->size[0] * i1].im = apnd * dcv0[i1].im +
                      cdiff * dcv0[i1].re;
                  }
                }

                c_exp(r6);
                for (i0 = 0; i0 < numberOfSubcarrierSubsets; i0++) {
                  b_csiFromEachPacket_data[i0].re = 0.0;
                  b_csiFromEachPacket_data[i0].im = 312500.0 * ((double)
                    subCarrInd_data[i0] * -6.2831853071795862);
                }

                for (i0 = 0; i0 < 601; i0++) {
                  dcv1[i0].re = dv2[i0];
                  dcv1[i0].im = 0.0;
                }

                i0 = r7->size[0] * r7->size[1];
                r7->size[0] = numberOfSubcarrierSubsets;
                r7->size[1] = 601;
                emxEnsureCapacity_creal_T(r7, i0);
                for (i0 = 0; i0 < numberOfSubcarrierSubsets; i0++) {
                  for (i1 = 0; i1 < 601; i1++) {
                    r7->data[i0 + r7->size[0] * i1].re = (double)(int)
                      b_csiFromEachPacket_data[i0].re * dcv1[i1].re -
                      b_csiFromEachPacket_data[i0].im * dcv1[i1].im;
                    r7->data[i0 + r7->size[0] * i1].im = (double)(int)
                      b_csiFromEachPacket_data[i0].re * dcv1[i1].im +
                      b_csiFromEachPacket_data[i0].im * dcv1[i1].re;
                  }
                }

                b_exp(r7);
                kron(r6, r7, steeringVector);
                nsDelayAngleSpotfiEstimated->size[0] = 2;
                nsDelayAngleSpotfiEstimated->size[1] = 0;
                for (t = 0; t < numberOfSpectrums; t++) {
                  b_loop_ub = matrixCSI->size[0];
                  c_loop_ub = matrixCSI->size[1];
                  i0 = mat->size[0] * mat->size[1];
                  mat->size[0] = b_loop_ub;
                  mat->size[1] = c_loop_ub;
                  emxEnsureCapacity_creal_T(mat, i0);
                  for (i0 = 0; i0 < c_loop_ub; i0++) {
                    for (i1 = 0; i1 < b_loop_ub; i1++) {
                      mat->data[i1 + mat->size[0] * i0] = matrixCSI->data[(i1 +
                        matrixCSI->size[0] * i0) + matrixCSI->size[0] *
                        matrixCSI->size[1] * t];
                    }
                  }

                  i0 = b->size[0] * b->size[1];
                  b->size[0] = mat->size[1];
                  b->size[1] = mat->size[0];
                  emxEnsureCapacity_creal_T(b, i0);
                  b_loop_ub = mat->size[0];
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    c_loop_ub = mat->size[1];
                    for (i1 = 0; i1 < c_loop_ub; i1++) {
                      b->data[i1 + b->size[0] * i0].re = mat->data[i0 +
                        mat->size[0] * i1].re;
                      b->data[i1 + b->size[0] * i0].im = -mat->data[i0 +
                        mat->size[0] * i1].im;
                    }
                  }

                  i0 = matrixCSI->size[1];
                  if ((i0 == 1) || (b->size[0] == 1)) {
                    i0 = Rxx->size[0] * Rxx->size[1];
                    Rxx->size[0] = mat->size[0];
                    Rxx->size[1] = b->size[1];
                    emxEnsureCapacity_creal_T(Rxx, i0);
                    b_loop_ub = mat->size[0];
                    for (i0 = 0; i0 < b_loop_ub; i0++) {
                      c_loop_ub = b->size[1];
                      for (i1 = 0; i1 < c_loop_ub; i1++) {
                        Rxx->data[i0 + Rxx->size[0] * i1].re = 0.0;
                        Rxx->data[i0 + Rxx->size[0] * i1].im = 0.0;
                        d_loop_ub = mat->size[1];
                        for (i2 = 0; i2 < d_loop_ub; i2++) {
                          apnd = mat->data[i0 + mat->size[0] * i2].re * b->
                            data[i2 + b->size[0] * i1].re - mat->data[i0 +
                            mat->size[0] * i2].im * b->data[i2 + b->size[0] * i1]
                            .im;
                          cdiff = mat->data[i0 + mat->size[0] * i2].re * b->
                            data[i2 + b->size[0] * i1].im + mat->data[i0 +
                            mat->size[0] * i2].im * b->data[i2 + b->size[0] * i1]
                            .re;
                          Rxx->data[i0 + Rxx->size[0] * i1].re += apnd;
                          Rxx->data[i0 + Rxx->size[0] * i1].im += cdiff;
                        }
                      }
                    }
                  } else {
                    i0 = matrixCSI->size[0];
                    i1 = matrixCSI->size[1];
                    remaining = b->size[1];
                    i2 = matrixCSI->size[0];
                    i3 = Rxx->size[0] * Rxx->size[1];
                    Rxx->size[0] = i2;
                    Rxx->size[1] = b->size[1];
                    emxEnsureCapacity_creal_T(Rxx, i3);
                    for (j = 0; j < remaining; j++) {
                      nm1d2 = j * i0;
                      boffset = j * i1;
                      for (i = 0; i < i0; i++) {
                        i2 = nm1d2 + i;
                        Rxx->data[i2].re = 0.0;
                        Rxx->data[i2].im = 0.0;
                      }

                      for (k = 0; k < i1; k++) {
                        aoffset = k * i0;
                        b_index = boffset + k;
                        apnd = b->data[b_index].re;
                        cdiff = b->data[b_index].im;
                        for (i = 0; i < i0; i++) {
                          b_index = aoffset + i;
                          temp_re = apnd * mat->data[b_index].re - cdiff *
                            mat->data[b_index].im;
                          temp_im = apnd * mat->data[b_index].im + cdiff *
                            mat->data[b_index].re;
                          i2 = nm1d2 + i;
                          Rxx->data[i2].re += temp_re;
                          Rxx->data[i2].im += temp_im;
                        }
                      }
                    }
                  }

                  eig(Rxx, Utmp);
                  b_abs(Rxx, r9);
                  diag(r9, d_data, csiFromEachPacket_size);
                  b_csiFromEachPacket_size[0] = csiFromEachPacket_size[0];
                  if (0 <= csiFromEachPacket_size[0] - 1) {
                    memcpy(&x_data[0], &d_data[0], (unsigned int)
                           (csiFromEachPacket_size[0] * (int)sizeof(double)));
                  }

                  sort(x_data, b_csiFromEachPacket_size, iidx_data,
                       csiFromEachPacket_size);
                  b_loop_ub = csiFromEachPacket_size[0];
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    x_data[i0] = iidx_data[i0];
                  }

                  b_loop_ub = csiFromEachPacket_size[0];
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    b_d_data[i0] = d_data[(int)x_data[i0] - 1];
                  }

                  if (0 <= csiFromEachPacket_size[0] - 1) {
                    memcpy(&d_data[0], &b_d_data[0], (unsigned int)
                           (csiFromEachPacket_size[0] * (int)sizeof(double)));
                  }

                  numberOfSourses = 0;
                  i0 = csiFromEachPacket_size[0];
                  for (i = 0; i < i0; i++) {
                    if (d_data[i] < 1.0) {
                      numberOfSourses = 1 + i;
                    }
                  }

                  /*  eig completed */
  		  end = time(NULL);
  		  printf("eig completed: %s\n", ctime(&end));

                  b_loop_ub = Utmp->size[0];
                  c_loop_ub = Utmp->size[0];
                  i0 = Pn->size[0] * Pn->size[1];
                  Pn->size[0] = c_loop_ub;
                  Pn->size[1] = csiFromEachPacket_size[0];
                  emxEnsureCapacity_creal_T(Pn, i0);
                  d_loop_ub = csiFromEachPacket_size[0];
                  for (i0 = 0; i0 < d_loop_ub; i0++) {
                    for (i1 = 0; i1 < c_loop_ub; i1++) {
                      Pn->data[i1 + Pn->size[0] * i0] = Utmp->data[i1 +
                        Utmp->size[0] * ((int)x_data[i0] - 1)];
                    }
                  }

                  i0 = Rxx->size[0] * Rxx->size[1];
                  Rxx->size[0] = b_loop_ub;
                  Rxx->size[1] = numberOfSourses;
                  emxEnsureCapacity_creal_T(Rxx, i0);
                  for (i0 = 0; i0 < numberOfSourses; i0++) {
                    for (i1 = 0; i1 < b_loop_ub; i1++) {
                      Rxx->data[i1 + Rxx->size[0] * i0] = Pn->data[i1 + Pn->
                        size[0] * i0];
                    }
                  }

                  i0 = b->size[0] * b->size[1];
                  b->size[0] = Rxx->size[1];
                  b->size[1] = Rxx->size[0];
                  emxEnsureCapacity_creal_T(b, i0);
                  b_loop_ub = Rxx->size[0];
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    c_loop_ub = Rxx->size[1];
                    for (i1 = 0; i1 < c_loop_ub; i1++) {
                      b->data[i1 + b->size[0] * i0].re = Rxx->data[i0 +
                        Rxx->size[0] * i1].re;
                      b->data[i1 + b->size[0] * i0].im = -Rxx->data[i0 +
                        Rxx->size[0] * i1].im;
                    }
                  }

                  if ((numberOfSourses == 1) || (b->size[0] == 1)) {
                    i0 = Pn->size[0] * Pn->size[1];
                    Pn->size[0] = Rxx->size[0];
                    Pn->size[1] = b->size[1];
                    emxEnsureCapacity_creal_T(Pn, i0);
                    b_loop_ub = Rxx->size[0];
                    for (i0 = 0; i0 < b_loop_ub; i0++) {
                      c_loop_ub = b->size[1];
                      for (i1 = 0; i1 < c_loop_ub; i1++) {
                        Pn->data[i0 + Pn->size[0] * i1].re = 0.0;
                        Pn->data[i0 + Pn->size[0] * i1].im = 0.0;
                        d_loop_ub = Rxx->size[1];
                        for (i2 = 0; i2 < d_loop_ub; i2++) {
                          apnd = Rxx->data[i0 + Rxx->size[0] * i2].re * b->
                            data[i2 + b->size[0] * i1].re - Rxx->data[i0 +
                            Rxx->size[0] * i2].im * b->data[i2 + b->size[0] * i1]
                            .im;
                          cdiff = Rxx->data[i0 + Rxx->size[0] * i2].re * b->
                            data[i2 + b->size[0] * i1].im + Rxx->data[i0 +
                            Rxx->size[0] * i2].im * b->data[i2 + b->size[0] * i1]
                            .re;
                          Pn->data[i0 + Pn->size[0] * i1].re += apnd;
                          Pn->data[i0 + Pn->size[0] * i1].im += cdiff;
                        }
                      }
                    }
                  } else {
                    i0 = Utmp->size[0];
                    remaining = b->size[1];
                    i1 = Utmp->size[0];
                    i2 = Pn->size[0] * Pn->size[1];
                    Pn->size[0] = i1;
                    Pn->size[1] = b->size[1];
                    emxEnsureCapacity_creal_T(Pn, i2);
                    for (j = 0; j < remaining; j++) {
                      nm1d2 = j * i0;
                      boffset = j * numberOfSourses;
                      for (i = 0; i < i0; i++) {
                        i1 = nm1d2 + i;
                        Pn->data[i1].re = 0.0;
                        Pn->data[i1].im = 0.0;
                      }

                      for (k = 0; k < numberOfSourses; k++) {
                        aoffset = k * i0;
                        b_index = boffset + k;
                        apnd = b->data[b_index].re;
                        cdiff = b->data[b_index].im;
                        for (i = 0; i < i0; i++) {
                          b_index = aoffset + i;
                          temp_re = apnd * Rxx->data[b_index].re - cdiff *
                            Rxx->data[b_index].im;
                          temp_im = apnd * Rxx->data[b_index].im + cdiff *
                            Rxx->data[b_index].re;
                          i1 = nm1d2 + i;
                          Pn->data[i1].re += temp_re;
                          Pn->data[i1].im += temp_im;
                        }
                      }
                    }
                  }

                  /*  Pn completed */
  		  end = time(NULL);
  		  printf("Pn completed: %s\n", ctime(&end));

                  if ((Pn->size[1] == 1) || (steeringVector->size[0] == 1)) {
                    i0 = b_y->size[0] * b_y->size[1];
                    b_y->size[0] = Pn->size[0];
                    b_y->size[1] = 1082401;
                    emxEnsureCapacity_creal_T(b_y, i0);
                    b_loop_ub = Pn->size[0];
                    for (i0 = 0; i0 < b_loop_ub; i0++) {
                      for (i1 = 0; i1 < 1082401; i1++) {
                        b_y->data[i0 + b_y->size[0] * i1].re = 0.0;
                        b_y->data[i0 + b_y->size[0] * i1].im = 0.0;
                        c_loop_ub = Pn->size[1];
                        for (i2 = 0; i2 < c_loop_ub; i2++) {
                          apnd = Pn->data[i0 + Pn->size[0] * i2].re *
                            steeringVector->data[i2 + steeringVector->size[0] *
                            i1].re - Pn->data[i0 + Pn->size[0] * i2].im *
                            steeringVector->data[i2 + steeringVector->size[0] *
                            i1].im;
                          cdiff = Pn->data[i0 + Pn->size[0] * i2].re *
                            steeringVector->data[i2 + steeringVector->size[0] *
                            i1].im + Pn->data[i0 + Pn->size[0] * i2].im *
                            steeringVector->data[i2 + steeringVector->size[0] *
                            i1].re;
                          b_y->data[i0 + b_y->size[0] * i1].re += apnd;
                          b_y->data[i0 + b_y->size[0] * i1].im += cdiff;
                        }
                      }
                    }
                  } else {
                    m = Pn->size[0];
                    remaining = Pn->size[1];
                    i0 = b_y->size[0] * b_y->size[1];
                    b_y->size[0] = Pn->size[0];
                    b_y->size[1] = 1082401;
                    emxEnsureCapacity_creal_T(b_y, i0);
                    for (j = 0; j < 1082401; j++) {
                      nm1d2 = j * m;
                      boffset = j * remaining;
                      for (i = 0; i < m; i++) {
                        i0 = nm1d2 + i;
                        b_y->data[i0].re = 0.0;
                        b_y->data[i0].im = 0.0;
                      }

                      for (k = 0; k < remaining; k++) {
                        aoffset = k * m;
                        b_index = boffset + k;
                        apnd = steeringVector->data[b_index].re;
                        cdiff = steeringVector->data[b_index].im;
                        for (i = 0; i < m; i++) {
                          b_index = aoffset + i;
                          temp_re = apnd * Pn->data[b_index].re - cdiff *
                            Pn->data[b_index].im;
                          temp_im = apnd * Pn->data[b_index].im + cdiff *
                            Pn->data[b_index].re;
                          i0 = nm1d2 + i;
                          b_y->data[i0].re += temp_re;
                          b_y->data[i0].im += temp_im;
                        }
                      }
                    }
                  }

                  i0 = b_steeringVector->size[0] * b_steeringVector->size[1];
                  b_steeringVector->size[0] = 1082401;
                  b_steeringVector->size[1] = steeringVector->size[0];
                  emxEnsureCapacity_creal_T(b_steeringVector, i0);
                  b_loop_ub = steeringVector->size[0];
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    for (i1 = 0; i1 < 1082401; i1++) {
                      apnd = steeringVector->data[i0 + steeringVector->size[0] *
                        i1].re;
                      cdiff = -steeringVector->data[i0 + steeringVector->size[0]
                        * i1].im;
                      temp_re = b_y->data[i0 + b_y->size[0] * i1].re;
                      temp_im = b_y->data[i0 + b_y->size[0] * i1].im;
                      i2 = i1 + 1082401 * i0;
                      b_steeringVector->data[i2].re = apnd * temp_re - cdiff *
                        temp_im;
                      b_steeringVector->data[i2].im = apnd * temp_im + cdiff *
                        temp_re;
                    }
                  }

                  sum(b_steeringVector, dcv2);
                  c_abs(dcv2, SpotfiSpectrum);
                  for (i0 = 0; i0 < 1082401; i0++) {
                    SpotfiSpectrum[i0] = 1.0 / SpotfiSpectrum[i0];
                  }

                  if (!rtIsNaN(SpotfiSpectrum[0])) {
                    b_index = 1;
                  } else {
                    b_index = 0;
                    k = 2;
                    exitg1 = false;
                    while ((!exitg1) && (k < 1082402)) {
                      if (!rtIsNaN(SpotfiSpectrum[k - 1])) {
                        b_index = k;
                        exitg1 = true;
                      } else {
                        k++;
                      }
                    }
                  }

                  if (b_index == 0) {
                    apnd = SpotfiSpectrum[0];
                  } else {
                    apnd = SpotfiSpectrum[b_index - 1];
                    i0 = b_index + 1;
                    for (k = i0; k < 1082402; k++) {
                      cdiff = SpotfiSpectrum[k - 1];
                      if (apnd > cdiff) {
                        apnd = cdiff;
                      }
                    }
                  }

                  for (i0 = 0; i0 < 1082401; i0++) {
                    SpotfiSpectrum[i0] -= apnd;
                  }

                  /*  spotfi completed */
  		  end = time(NULL);
  		  printf("spotfi completed: %s\n", ctime(&end));

                  imregionalmax(SpotfiSpectrum, isPeak);
                  b_index = 0;
                  i0 = ii->size[0];
                  ii->size[0] = 1082401;
                  emxEnsureCapacity_int32_T(ii, i0);
                  remaining = 0;
                  exitg1 = false;
                  while ((!exitg1) && (remaining < 1082401)) {
                    if (isPeak[remaining]) {
                      b_index++;
                      ii->data[b_index - 1] = remaining + 1;
                      if (b_index >= 1082401) {
                        exitg1 = true;
                      } else {
                        remaining++;
                      }
                    } else {
                      remaining++;
                    }
                  }

                  if (1 > b_index) {
                    ii->size[0] = 0;
                  } else {
                    i0 = ii->size[0];
                    ii->size[0] = b_index;
                    emxEnsureCapacity_int32_T(ii, i0);
                  }

                  i0 = ii->size[0];
                  emxEnsureCapacity_int32_T(ii, i0);
                  b_loop_ub = ii->size[0];
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    ii->data[i0]--;
                  }

                  i0 = vk->size[0];
                  vk->size[0] = ii->size[0];
                  emxEnsureCapacity_int16_T(vk, i0);
                  b_loop_ub = ii->size[0];
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    vk->data[i0] = (short)(ii->data[i0] / 601);
                  }

                  i0 = ii->size[0];
                  emxEnsureCapacity_int32_T(ii, i0);
                  b_loop_ub = ii->size[0];
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    ii->data[i0] -= vk->data[i0] * 601;
                  }

                  i0 = ii->size[0];
                  emxEnsureCapacity_int32_T(ii, i0);
                  b_loop_ub = ii->size[0];
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    ii->data[i0]++;
                  }

                  i0 = vk->size[0];
                  emxEnsureCapacity_int16_T(vk, i0);
                  b_loop_ub = vk->size[0];
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    vk->data[i0]++;
                  }

                  b_index = 0;
                  for (i = 0; i < 1082401; i++) {
                    if (isPeak[i]) {
                      b_index++;
                    }
                  }

                  i0 = r4->size[0];
                  r4->size[0] = b_index;
                  emxEnsureCapacity_int32_T(r4, i0);
                  remaining = 0;
                  for (i = 0; i < 1082401; i++) {
                    if (isPeak[i]) {
                      r4->data[remaining] = i + 1;
                      remaining++;
                    }
                  }

                  i0 = varargin_1->size[0];
                  varargin_1->size[0] = r4->size[0];
                  emxEnsureCapacity_real_T(varargin_1, i0);
                  b_loop_ub = r4->size[0];
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    varargin_1->data[i0] = SpotfiSpectrum[r4->data[i0] - 1];
                  }

                  remaining = r4->size[0];
                  if (varargin_1->size[0] <= 2) {
                    if (varargin_1->size[0] == 1) {
                      apnd = SpotfiSpectrum[r4->data[0] - 1];
                    } else if ((SpotfiSpectrum[r4->data[0] - 1] <
                                SpotfiSpectrum[r4->data[1] - 1]) || (rtIsNaN
                                (SpotfiSpectrum[r4->data[0] - 1]) && (!rtIsNaN
                                 (SpotfiSpectrum[r4->data[1] - 1])))) {
                      apnd = SpotfiSpectrum[r4->data[1] - 1];
                    } else {
                      apnd = SpotfiSpectrum[r4->data[0] - 1];
                    }
                  } else {
                    if (!rtIsNaN(varargin_1->data[0])) {
                      b_index = 1;
                    } else {
                      b_index = 0;
                      k = 2;
                      exitg1 = false;
                      while ((!exitg1) && (k <= varargin_1->size[0])) {
                        if (!rtIsNaN(varargin_1->data[k - 1])) {
                          b_index = k;
                          exitg1 = true;
                        } else {
                          k++;
                        }
                      }
                    }

                    if (b_index == 0) {
                      apnd = SpotfiSpectrum[r4->data[0] - 1];
                    } else {
                      apnd = SpotfiSpectrum[r4->data[b_index - 1] - 1];
                      i0 = b_index + 1;
                      for (k = i0; k <= remaining; k++) {
                        if (apnd < SpotfiSpectrum[r4->data[k - 1] - 1]) {
                          apnd = SpotfiSpectrum[r4->data[k - 1] - 1];
                        }
                      }
                    }
                  }

                  cdiff = 0.1 * apnd;
                  i0 = isStrongEnough->size[0];
                  isStrongEnough->size[0] = r4->size[0];
                  emxEnsureCapacity_boolean_T(isStrongEnough, i0);
                  b_loop_ub = r4->size[0];
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    isStrongEnough->data[i0] = (SpotfiSpectrum[r4->data[i0] - 1]
                      > cdiff);
                  }

                  nm1d2 = isStrongEnough->size[0] - 1;
                  b_index = 0;
                  for (i = 0; i <= nm1d2; i++) {
                    if (isStrongEnough->data[i]) {
                      b_index++;
                    }
                  }

                  remaining = 0;
                  for (i = 0; i <= nm1d2; i++) {
                    if (isStrongEnough->data[i]) {
                      ii->data[remaining] = ii->data[i];
                      remaining++;
                    }
                  }

                  i0 = ii->size[0];
                  ii->size[0] = b_index;
                  emxEnsureCapacity_int32_T(ii, i0);
                  nm1d2 = isStrongEnough->size[0] - 1;
                  b_index = 0;
                  for (i = 0; i <= nm1d2; i++) {
                    if (isStrongEnough->data[i]) {
                      b_index++;
                    }
                  }

                  remaining = 0;
                  for (i = 0; i <= nm1d2; i++) {
                    if (isStrongEnough->data[i]) {
                      vk->data[remaining] = vk->data[i];
                      remaining++;
                    }
                  }

                  i0 = vk->size[0];
                  vk->size[0] = b_index;
                  emxEnsureCapacity_int16_T(vk, i0);
                  i0 = newEstimation->size[0] * newEstimation->size[1];
                  newEstimation->size[0] = 2;
                  newEstimation->size[1] = ii->size[0];
                  emxEnsureCapacity_real_T(newEstimation, i0);
                  b_loop_ub = ii->size[0];
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    newEstimation->data[i0 << 1] = (-3.0000000000000004E-7 +
                      ((double)ii->data[i0] - 1.0) * 1.0E-9) * 1.0E+9;
                  }

                  b_loop_ub = vk->size[0];
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    newEstimation->data[1 + (i0 << 1)] = -90.0 + ((double)
                      vk->data[i0] - 1.0) * 0.1;
                  }

                  b_loop_ub = newEstimation->size[1];
                  i0 = r2->size[0] * r2->size[1];
                  r2->size[0] = 1;
                  r2->size[1] = b_loop_ub;
                  emxEnsureCapacity_boolean_T(r2, i0);
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    r2->data[i0] = (newEstimation->data[1 + (i0 << 1)] > -89.0);
                  }

                  b_loop_ub = newEstimation->size[1];
                  i0 = r3->size[0] * r3->size[1];
                  r3->size[0] = 1;
                  r3->size[1] = b_loop_ub;
                  emxEnsureCapacity_boolean_T(r3, i0);
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    r3->data[i0] = (newEstimation->data[1 + (i0 << 1)] < 89.0);
                  }

                  nm1d2 = r2->size[1] - 1;
                  b_index = 0;
                  for (i = 0; i <= nm1d2; i++) {
                    if (r2->data[i] && r3->data[i]) {
                      b_index++;
                    }
                  }

                  i0 = r5->size[0] * r5->size[1];
                  r5->size[0] = 1;
                  r5->size[1] = b_index;
                  emxEnsureCapacity_int32_T(r5, i0);
                  remaining = 0;
                  for (i = 0; i <= nm1d2; i++) {
                    if (r2->data[i] && r3->data[i]) {
                      r5->data[remaining] = i + 1;
                      remaining++;
                    }
                  }

                  i0 = b_newEstimation->size[0] * b_newEstimation->size[1];
                  b_newEstimation->size[0] = 2;
                  b_newEstimation->size[1] = r5->size[1];
                  emxEnsureCapacity_real_T(b_newEstimation, i0);
                  b_loop_ub = r5->size[1];
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    i1 = i0 << 1;
                    b_newEstimation->data[i1] = newEstimation->data[(r5->data[i0]
                      - 1) << 1];
                    b_newEstimation->data[1 + i1] = newEstimation->data[1 +
                      ((r5->data[i0] - 1) << 1)];
                  }

                  i0 = newEstimation->size[0] * newEstimation->size[1];
                  newEstimation->size[0] = 2;
                  newEstimation->size[1] = b_newEstimation->size[1];
                  emxEnsureCapacity_real_T(newEstimation, i0);
                  b_loop_ub = b_newEstimation->size[0] * b_newEstimation->size[1];
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    newEstimation->data[i0] = b_newEstimation->data[i0];
                  }

                  i0 = b_nsDelayAngleSpotfiEstimated->size[0] *
                    b_nsDelayAngleSpotfiEstimated->size[1];
                  b_nsDelayAngleSpotfiEstimated->size[0] = 2;
                  b_nsDelayAngleSpotfiEstimated->size[1] =
                    nsDelayAngleSpotfiEstimated->size[1] + newEstimation->size[1];
                  emxEnsureCapacity_real_T(b_nsDelayAngleSpotfiEstimated, i0);
                  b_loop_ub = nsDelayAngleSpotfiEstimated->size[1];
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    i1 = i0 << 1;
                    b_nsDelayAngleSpotfiEstimated->data[i1] =
                      nsDelayAngleSpotfiEstimated->data[i1];
                    i1++;
                    b_nsDelayAngleSpotfiEstimated->data[i1] =
                      nsDelayAngleSpotfiEstimated->data[i1];
                  }

                  b_loop_ub = newEstimation->size[1];
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    i1 = i0 << 1;
                    b_nsDelayAngleSpotfiEstimated->data[(i0 +
                      nsDelayAngleSpotfiEstimated->size[1]) << 1] =
                      newEstimation->data[i1];
                    b_nsDelayAngleSpotfiEstimated->data[1 + ((i0 +
                      nsDelayAngleSpotfiEstimated->size[1]) << 1)] =
                      newEstimation->data[1 + i1];
                  }

                  i0 = nsDelayAngleSpotfiEstimated->size[0] *
                    nsDelayAngleSpotfiEstimated->size[1];
                  nsDelayAngleSpotfiEstimated->size[0] = 2;
                  nsDelayAngleSpotfiEstimated->size[1] =
                    b_nsDelayAngleSpotfiEstimated->size[1];
                  emxEnsureCapacity_real_T(nsDelayAngleSpotfiEstimated, i0);
                  b_loop_ub = b_nsDelayAngleSpotfiEstimated->size[0] *
                    b_nsDelayAngleSpotfiEstimated->size[1];
                  for (i0 = 0; i0 < b_loop_ub; i0++) {
                    nsDelayAngleSpotfiEstimated->data[i0] =
                      b_nsDelayAngleSpotfiEstimated->data[i0];
                  }

                  /*  peaks completed */
  		  end = time(NULL);
  		  printf("peaks completed: %s\n", ctime(&end));

                  /*                                  fileID = fopen(directory+"SpotfiEigen" + seed_str + ".txt", 'a'); */
                  /*                                  fprintf(fileID, "noise: "); */
                  /*                                  for i = 1:numberOfSourses */
                  /*                                      fprintf(fileID, "%.3f ", d(i)); */
                  /*                                  end */
                  /*                                  fprintf(fileID, "signal: "); */
                  /*                                  for i = numberOfSourses+1:length(d) */
                  /*                                      fprintf(fileID, "%.3f ", d(i)); */
                  /*                                  end */
                  /*                                  fprintf(fileID, "\n"); */
                  /*                                  fclose(fileID); */
                }

                obj_Value[0] = 'r';
                obj_Value[1] = '_';
                for (i0 = 0; i0 < 5; i0++) {
                  obj_Value[i0 + 2] = seed_str[i0];
                  obj_Value[i0 + 7] = cv1[i0];
                }

                string_string(b_ant, filename_Value_data, filename_Value_size);
                string_plus(obj_Value, filename_Value_data, filename_Value_size,
                            name_Value_data, name_Value_size);
                b_string_plus(name_Value_data, name_Value_size,
                              filename_Value_data, filename_Value_size);
                string_string(1.0 - (double)smoothing, name_Value_data,
                              name_Value_size);
                c_string_plus(filename_Value_data, filename_Value_size,
                              name_Value_data, name_Value_size, t0_Value_data,
                              t0_Value_size);
                d_string_plus(t0_Value_data, t0_Value_size, filename_Value_data,
                              filename_Value_size);
                string_string(1.0 - (double)backw, name_Value_data,
                              name_Value_size);
                c_string_plus(filename_Value_data, filename_Value_size,
                              name_Value_data, name_Value_size, t0_Value_data,
                              t0_Value_size);
                e_string_plus(t0_Value_data, t0_Value_size, filename_Value_data,
                              filename_Value_size);
                string_string(b_p, name_Value_data, name_Value_size);
                c_string_plus(filename_Value_data, filename_Value_size,
                              name_Value_data, name_Value_size, t0_Value_data,
                              t0_Value_size);
                f_string_plus(t0_Value_data, t0_Value_size, filename_Value_data,
                              filename_Value_size);
                string_string(2.0 - (double)perSpec, name_Value_data,
                              name_Value_size);
                c_string_plus(filename_Value_data, filename_Value_size,
                              name_Value_data, name_Value_size, t0_Value_data,
                              t0_Value_size);
                g_string_plus(t0_Value_data, t0_Value_size, filename_Value_data,
                              filename_Value_size);
                string_string(b_band, name_Value_data, name_Value_size);
                c_string_plus(filename_Value_data, filename_Value_size,
                              name_Value_data, name_Value_size, t0_Value_data,
                              t0_Value_size);
                h_string_plus(t0_Value_data, t0_Value_size, filename_Value_data,
                              filename_Value_size);
                string_string(dec, name_Value_data, name_Value_size);
                c_string_plus(filename_Value_data, filename_Value_size,
                              name_Value_data, name_Value_size, t0_Value_data,
                              t0_Value_size);
                i_string_plus(t0_Value_data, t0_Value_size, name_Value_data,
                              name_Value_size);
                j_string_plus(name_Value_data, name_Value_size,
                              filename_Value_data, filename_Value_size);
                fileid = b_cfopen(filename_Value_data, filename_Value_size, "wb");
                i0 = nsDelayAngleSpotfiEstimated->size[1];
                for (j = 0; j < i0; j++) {
                  b_NULL = NULL;
                  getfilestar(fileid, &filestar, &autoflush);
                  if (!(filestar == b_NULL)) {
                    fprintf(filestar, "%.1f ", nsDelayAngleSpotfiEstimated->
                            data[j << 1]);
                    if (autoflush) {
                      fflush(filestar);
                    }
                  }

                  if (!(filestar == b_NULL)) {
                    fprintf(filestar, "%.1f ", nsDelayAngleSpotfiEstimated->
                            data[1 + (j << 1)]);
                    if (autoflush) {
                      fflush(filestar);
                    }
                  }
                }

                b_fclose(fileid);
              }
            }
          }
        }
      }
    }
  }

  emxFree_real_T(&b_nsDelayAngleSpotfiEstimated);
  emxFree_real_T(&b_newEstimation);
  emxFree_creal_T(&b_steeringVector);
  emxFree_real_T(&r9);
  emxFree_creal_T(&r8);
  emxFree_creal_T(&r7);
  emxFree_creal_T(&r6);
  emxFree_real_T(&varargin_1);
  emxFree_int16_T(&vk);
  emxFree_int32_T(&ii);
  emxFree_creal_T(&b_y);
  emxFree_creal_T(&b);
  emxFree_int32_T(&r5);
  emxFree_int32_T(&r4);
  emxFree_boolean_T(&r3);
  emxFree_boolean_T(&r2);
  emxFree_creal_T(&r1);
  emxFree_creal_T(&Utmp);
  emxFree_real_T(&newEstimation);
  emxFree_boolean_T(&isStrongEnough);
  emxFree_creal_T(&Pn);
  emxFree_creal_T(&Rxx);
  emxFree_creal_T(&mat);
  emxFree_real_T(&nsDelayAngleSpotfiEstimated);
  emxFree_creal_T(&steeringVector);
  emxFree_creal_T(&conjCsiTracePerPacket);
  emxFree_creal_T(&tmp);
  emxFree_creal_T(&De);
  emxFree_creal_T(&D);
  emxFree_creal_T(&smoothedMatrixCSI);
  emxFree_creal_T(&matrixCSI);

  /*  Spotfi */
}

/*
 * File trailer for forCoder.c
 *
 * [EOF]
 */
