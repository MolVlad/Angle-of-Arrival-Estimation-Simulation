/*
 * File: forCoder.c
 *
 * MATLAB Coder version            : 4.1
 * C/C++ source code generated on  : 15-Jul-2020 16:30:48
 */

/* Include Files */
#include <math.h>
#include <string.h>
#include "rt_nonfinite.h"
#include "forCoder.h"
#include "forCoder_emxutil.h"
#include "fclose.h"
#include "fileManager.h"
#include "string1.h"
#include "imregionalmax.h"
#include "abs.h"
#include "sum.h"
#include "sort1.h"
#include "diag.h"
#include "eig.h"
#include "kron.h"
#include "exp.h"
#include "hankel.h"
#include "str2double.h"
#include "char.h"
#include "fread.h"
#include "fseek.h"
#include "ftell.h"
#include "sprintf.h"
#include "forCoder_rtwutil.h"
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

/* Function Declarations */
static int div_s32_floor(int numerator, int denominator);

/* Function Definitions */

/*
 * Arguments    : int numerator
 *                int denominator
 * Return Type  : int
 */
static int div_s32_floor(int numerator, int denominator)
{
  int quotient;
  unsigned int absNumerator;
  unsigned int absDenominator;
  boolean_T quotientNeedsNegation;
  unsigned int tempAbsQuotient;
  if (denominator == 0) {
    if (numerator >= 0) {
      quotient = MAX_int32_T;
    } else {
      quotient = MIN_int32_T;
    }
  } else {
    if (numerator < 0) {
      absNumerator = ~(unsigned int)numerator + 1U;
    } else {
      absNumerator = (unsigned int)numerator;
    }

    if (denominator < 0) {
      absDenominator = ~(unsigned int)denominator + 1U;
    } else {
      absDenominator = (unsigned int)denominator;
    }

    quotientNeedsNegation = ((numerator < 0) != (denominator < 0));
    tempAbsQuotient = absNumerator / absDenominator;
    if (quotientNeedsNegation) {
      absNumerator %= absDenominator;
      if (absNumerator > 0U) {
        tempAbsQuotient++;
      }

      quotient = -(int)tempAbsQuotient;
    } else {
      quotient = (int)tempAbsQuotient;
    }
  }

  return quotient;
}

/*
 * Arguments    : double seed
 * Return Type  : void
 */
void forCoder(double seed)
{
  emxArray_char_T *s;
  double cdiff;
  int i0;
  char seed_str[5];
  int loop_ub;
  int i1;
  char subdir_Value[11];
  static const char cv0[6] = { 'm', 'u', 's', 'i', 'c', '_' };

  signed char fileid;
  FILE * b_NULL;
  FILE * filestar;
  boolean_T autoflush;
  char filename_Value[15];
  static const char cv1[6] = { '.', '/', 'c', 's', 'i', '_' };

  static unsigned char buffer[2097152];
  int remaining;
  int b_index;
  emxArray_real_T *dataRead;
  emxArray_int32_T *r0;
  boolean_T exitg1;
  int nm1d2;
  emxArray_uint8_T *b_buffer;
  double apnd;
  emxArray_char_T *str;
  int i2;
  int k;
  emxArray_char_T *b_str;
  int i;
  int j;
  unsigned char start_idx;
  emxArray_creal_T *matrixCSI;
  emxArray_creal_T *smoothedMatrixCSI;
  emxArray_creal_T *D;
  emxArray_creal_T *De;
  emxArray_creal_T *tmp;
  static creal_T y[28800];
  emxArray_creal_T *conjCsiTracePerPacket;
  emxArray_creal_T *steeringVector;
  emxArray_real_T *nsDelayAngleSpotfiEstimated;
  emxArray_creal_T *mat;
  emxArray_creal_T *Rxx;
  emxArray_creal_T *Pn;
  emxArray_creal_T *Utmp;
  emxArray_creal_T *b;
  emxArray_creal_T *b_y;
  emxArray_real_T *r1;
  emxArray_creal_T *b_steeringVector;
  emxArray_real_T *b_nsDelayAngleSpotfiEstimated;
  int ant;
  int b_ant;
  int p;
  int b_p;
  int perSpec;
  int numberOfSpectrums;
  int loop_ub_tmp;
  int dec;
  int subCarrInd_size_idx_1;
  int varargin_2;
  int numberOfSubcarrierSubsets;
  int b_loop_ub;
  int smoothing;
  signed char subCarrInd_data[56];
  int subarrayNum;
  int numberOfAntennaInSubset;
  double a;
  double b_b;
  int backw;
  static const signed char iv0[2] = { 1, 0 };

  int boffset;
  int columnsNum;
  int aoffset;
  int c_loop_ub;
  int d_loop_ub;
  int t;
  signed char y_data[28];
  int e_loop_ub;
  int i3;
  double b_y_data[8];
  creal_T csiFromEachPacket_data[456];
  int tmp_size[2];
  creal_T dcv0[21];
  static const double dv0[21] = { -0.5, -0.49384417029756889,
    -0.47552825814757677, -0.44550326209418395, -0.40450849718747373,
    -0.35355339059327373, -0.29389262614623657, -0.22699524986977337,
    -0.1545084971874737, -0.078217232520115434, 0.0, 0.078217232520115434,
    0.1545084971874737, 0.22699524986977337, 0.29389262614623657,
    0.35355339059327373, 0.40450849718747373, 0.44550326209418395,
    0.47552825814757677, 0.49384417029756889, 0.5 };

  int m;
  creal_T tmp_data[168];
  int csiFromEachPacket_size[1];
  creal_T b_csiFromEachPacket_data[28];
  int b_tmp_size[2];
  creal_T dcv1[61];
  static const double dv1[61] = { -3.0000000000000004E-7, -2.9000000000000003E-7,
    -2.8E-7, -2.7000000000000006E-7, -2.6000000000000005E-7,
    -2.5000000000000004E-7, -2.4000000000000003E-7, -2.3000000000000002E-7,
    -2.2E-7, -2.1000000000000003E-7, -2.0000000000000002E-7,
    -1.9000000000000003E-7, -1.8000000000000002E-7, -1.7000000000000001E-7,
    -1.6E-7, -1.5000000000000002E-7, -1.4E-7, -1.3E-7, -1.2000000000000002E-7,
    -1.1E-7, -1.0E-7, -9.0000000000000012E-8, -8.0E-8, -6.9999999999999992E-8,
    -6.0000000000000008E-8, -5.0E-8, -3.9999999999999988E-8,
    -2.9999999999999977E-8, -1.9999999999999967E-8, -1.000000000000001E-8, 0.0,
    1.000000000000001E-8, 2.000000000000002E-8, 3.000000000000003E-8,
    4.0000000000000041E-8, 5.0000000000000051E-8, 6.0000000000000008E-8,
    7.0000000000000018E-8, 8.0000000000000028E-8, 9.0000000000000038E-8,
    1.0000000000000005E-7, 1.1000000000000006E-7, 1.2000000000000002E-7,
    1.3000000000000003E-7, 1.4000000000000004E-7, 1.5000000000000005E-7,
    1.6000000000000006E-7, 1.7000000000000007E-7, 1.8000000000000002E-7,
    1.9000000000000003E-7, 2.0000000000000004E-7, 2.1000000000000005E-7,
    2.2000000000000006E-7, 2.3000000000000007E-7, 2.4000000000000008E-7,
    2.5000000000000009E-7, 2.600000000000001E-7, 2.7000000000000011E-7, 2.8E-7,
    2.9000000000000003E-7, 3.0000000000000004E-7 };

  int b_csiFromEachPacket_size[1];
  static creal_T b_tmp_data[1708];
  creal_T c_csiFromEachPacket_data[56];
  creal_T c_tmp_data[1568];
  int c_tmp_size[2];
  char obj_Value[12];
  char filename_Value_data[1476];
  char name_Value_data[1476];
  int name_Value_size[2];
  static const char cv2[5] = { '_', 'a', 'n', 't', '_' };

  unsigned char d_tmp_data[28];
  char t0_Value_data[1476];
  int t0_Value_size[2];
  creal_T e_tmp_data[1596];
  char b_obj_Value[14];
  double d_data[224];
  double x_data[224];
  int iidx_data[224];
  double b_d_data[224];
  double temp_re;
  double temp_im;
  creal_T dcv2[1281];
  double SpotfiSpectrum[1281];
  boolean_T isPeak[1281];
  short ii_data[1281];
  signed char vk_data[1281];
  short f_tmp_data[1281];
  double varargin_1_data[1281];
  boolean_T isStrongEnough_data[1281];
  double newEstimation_data[2562];
  boolean_T g_tmp_data[1281];
  boolean_T h_tmp_data[1281];
  short i_tmp_data[1281];
  double b_newEstimation_data[2562];
  emxInit_char_T(&s, 2);

  /*  ЗДЕСЬ НУЖНО ЗАМЕНИТЬ 181 на 1801 и 61 на 601 !!!!! */
  /*  ЗДЕСЬ НУЖНО ЗАМЕНИТЬ 181 на 1801 и 61 на 601 !!!!! */
  cdiff = rt_roundd_snf(seed);
  if (cdiff < 2.147483648E+9) {
    if (cdiff >= -2.147483648E+9) {
      i0 = (int)cdiff;
    } else {
      i0 = MIN_int32_T;
    }
  } else if (cdiff >= 2.147483648E+9) {
    i0 = MAX_int32_T;
  } else {
    i0 = 0;
  }

  b_sprintf(i0, s);
  for (i0 = 0; i0 < 5; i0++) {
    seed_str[i0] = '0';
  }

  if (6 - s->size[1] > 5) {
    i0 = 0;
  } else {
    i0 = 5 - s->size[1];
  }

  loop_ub = s->size[1];
  for (i1 = 0; i1 < loop_ub; i1++) {
    seed_str[i0 + i1] = s->data[i1];
  }

  emxFree_char_T(&s);
  for (i0 = 0; i0 < 6; i0++) {
    subdir_Value[i0] = cv0[i0];
  }

  for (i0 = 0; i0 < 5; i0++) {
    subdir_Value[i0 + 6] = seed_str[i0];
  }

  mkdir(subdir_Value, 0777);
  fileid = cfopen("lol.txt", "wb");
  b_NULL = NULL;
  getfilestar(fileid, &filestar, &autoflush);
  if (!(filestar == b_NULL)) {
    fprintf(filestar, "lol\n");
    if (autoflush) {
      fflush(filestar);
    }
  }

  for (i0 = 0; i0 < 6; i0++) {
    filename_Value[i0] = cv1[i0];
  }

  for (i0 = 0; i0 < 5; i0++) {
    filename_Value[i0 + 6] = seed_str[i0];
  }

  filename_Value[11] = '.';
  filename_Value[12] = 't';
  filename_Value[13] = 'x';
  filename_Value[14] = 't';
  fileid = b_cfopen(filename_Value, "rb");
  b_fseek(fileid);
  cdiff = rt_roundd_snf(b_ftell(fileid));
  if (cdiff < 2.147483648E+9) {
    if (cdiff >= -2.147483648E+9) {
      i0 = (int)cdiff;
    } else {
      i0 = MIN_int32_T;
    }
  } else if (cdiff >= 2.147483648E+9) {
    i0 = MAX_int32_T;
  } else {
    i0 = 0;
  }

  c_fseek(fileid);
  memset(&buffer[0], 0, sizeof(unsigned char) << 21);
  remaining = i0;
  b_index = 1;
  emxInit_real_T(&dataRead, 1);
  emxInit_int32_T(&r0, 2);
  exitg1 = false;
  while ((!exitg1) && (remaining > 0)) {
    if (b_index > MAX_int32_T - remaining) {
      nm1d2 = MAX_int32_T;
    } else {
      nm1d2 = remaining + b_index;
    }

    if (nm1d2 > 2097152) {
      printf("Attempt to read file which is bigger than internal buffer.\n");
      fflush(stdout);
      printf("Current buffer size is %d bytes and file size is %d bytes.\n",
             2097152, i0);
      fflush(stdout);
      exitg1 = true;
    } else {
      b_fread(fileid, remaining, dataRead, &apnd);
      cdiff = rt_roundd_snf((double)b_index + apnd);
      if (cdiff < 2.147483648E+9) {
        if (cdiff >= -2.147483648E+9) {
          nm1d2 = (int)cdiff;
        } else {
          nm1d2 = MIN_int32_T;
        }
      } else if (cdiff >= 2.147483648E+9) {
        nm1d2 = MAX_int32_T;
      } else {
        nm1d2 = 0;
      }

      if (nm1d2 < -2147483647) {
        nm1d2 = MIN_int32_T;
      } else {
        nm1d2--;
      }

      if (b_index > nm1d2) {
        i1 = 0;
        nm1d2 = 0;
      } else {
        i1 = b_index - 1;
      }

      i2 = r0->size[0] * r0->size[1];
      r0->size[0] = 1;
      loop_ub = nm1d2 - i1;
      r0->size[1] = loop_ub;
      emxEnsureCapacity_int32_T(r0, i2);
      for (i2 = 0; i2 < loop_ub; i2++) {
        r0->data[i2] = i1 + i2;
      }

      loop_ub = r0->size[0] * r0->size[1];
      for (i1 = 0; i1 < loop_ub; i1++) {
        cdiff = rt_roundd_snf(dataRead->data[i1]);
        if (cdiff < 256.0) {
          if (cdiff >= 0.0) {
            start_idx = (unsigned char)cdiff;
          } else {
            start_idx = 0U;
          }
        } else if (cdiff >= 256.0) {
          start_idx = MAX_uint8_T;
        } else {
          start_idx = 0U;
        }

        buffer[r0->data[i1]] = start_idx;
      }

      cdiff = rt_roundd_snf(apnd);
      if (cdiff < 2.147483648E+9) {
        if (cdiff >= -2.147483648E+9) {
          nm1d2 = (int)cdiff;
        } else {
          nm1d2 = MIN_int32_T;
        }
      } else if (cdiff >= 2.147483648E+9) {
        nm1d2 = MAX_int32_T;
      } else {
        nm1d2 = 0;
      }

      if (nm1d2 == 0) {
        exitg1 = true;
      } else {
        /*  Did something went wrong when reading? */
        if (nm1d2 < 0) {
          printf("Could not read from file: %d.\n", nm1d2);
          fflush(stdout);
          exitg1 = true;
        } else {
          /*  Update state variables */
          remaining -= nm1d2;
          if ((b_index < 0) && (nm1d2 < MIN_int32_T - b_index)) {
            b_index = MIN_int32_T;
          } else if ((b_index > 0) && (nm1d2 > MAX_int32_T - b_index)) {
            b_index = MAX_int32_T;
          } else {
            b_index += nm1d2;
          }
        }
      }
    }
  }

  emxFree_int32_T(&r0);
  emxFree_real_T(&dataRead);
  emxInit_uint8_T(&b_buffer, 2);

  /*  Close file */
  b_fclose(fileid);
  i0 = b_buffer->size[0] * b_buffer->size[1];
  b_buffer->size[0] = 1;
  b_buffer->size[1] = b_index;
  emxEnsureCapacity_uint8_T(b_buffer, i0);
  for (i0 = 0; i0 < b_index; i0++) {
    b_buffer->data[i0] = buffer[i0];
  }

  emxInit_char_T(&str, 2);
  b_char(b_buffer, str);
  emxFree_uint8_T(&b_buffer);
  i0 = str->size[0] * str->size[1];
  if (1 > b_index - 1) {
    str->size[1] = 0;
  } else {
    str->size[1] = b_index - 1;
  }

  emxEnsureCapacity_char_T(str, i0);
  k = 1;
  emxInit_char_T(&b_str, 2);
  for (i = 0; i < 28800; i++) {
    for (j = k - 1; str->data[j] != ' '; j++) {
    }

    if (k > j) {
      i0 = 0;
      i1 = 0;
    } else {
      i0 = k - 1;
      i1 = j;
    }

    i2 = b_str->size[0] * b_str->size[1];
    b_str->size[0] = 1;
    loop_ub = i1 - i0;
    b_str->size[1] = loop_ub;
    emxEnsureCapacity_char_T(b_str, i2);
    for (i1 = 0; i1 < loop_ub; i1++) {
      b_str->data[i1] = str->data[i0 + i1];
    }

    y[i] = str2double(b_str);
    k = j + 2;
  }

  emxFree_char_T(&b_str);
  emxFree_char_T(&str);

  /*  reading completed */
  /*  packetNum = [10]; */
  /*  packetPerSpectrum = [1]; */
  /*  antennasNum = [4]; */
  /*  bandwidth = [20]; */
  /*  subcarrierDecimationUsed = [1]; */
  /*  backwardSmoothing = [0]; */
  /*  useSmothing = [0]; */
  emxInit_creal_T(&matrixCSI, 3);
  emxInit_creal_T(&smoothedMatrixCSI, 3);
  emxInit_creal_T(&D, 3);
  emxInit_creal_T(&De, 2);
  emxInit_creal_T(&tmp, 2);
  emxInit_creal_T(&conjCsiTracePerPacket, 3);
  emxInit_creal_T(&steeringVector, 2);
  emxInit_real_T(&nsDelayAngleSpotfiEstimated, 2);
  emxInit_creal_T(&mat, 2);
  emxInit_creal_T(&Rxx, 2);
  emxInit_creal_T(&Pn, 2);
  emxInit_creal_T(&Utmp, 2);
  emxInit_creal_T(&b, 2);
  emxInit_creal_T(&b_y, 2);
  emxInit_real_T(&r1, 2);
  emxInit_creal_T(&b_steeringVector, 2);
  emxInit_real_T(&b_nsDelayAngleSpotfiEstimated, 2);
  for (ant = 0; ant < 2; ant++) {
    b_ant = 8 + -4 * ant;
    for (p = 0; p < 2; p++) {
      b_p = 30 + -20 * p;
      for (perSpec = 0; perSpec < 2; perSpec++) {
        numberOfSpectrums = (int)floor((double)b_p / (2.0 - (double)perSpec));
        loop_ub_tmp = numberOfSpectrums * (2 - perSpec);
        for (dec = 0; dec < 2; dec++) {
          if (dec != 0) {
            nm1d2 = 2;
          } else {
            nm1d2 = 1;
          }

          subCarrInd_size_idx_1 = (int)floor(55.0 / (double)nm1d2) + 1;
          loop_ub = (int)floor(55.0 / (double)nm1d2);
          varargin_2 = subCarrInd_size_idx_1 + 1;
          numberOfSubcarrierSubsets = (int)floor((double)subCarrInd_size_idx_1 /
            2.0);
          b_loop_ub = subCarrInd_size_idx_1 * b_ant * loop_ub_tmp;
          for (i0 = 0; i0 <= loop_ub; i0++) {
            subCarrInd_data[i0] = (signed char)(1 + nm1d2 * i0);
          }

          for (smoothing = 0; smoothing < 2; smoothing++) {
            if (1 - smoothing != 0) {
              switch (b_ant) {
               case 8:
                subarrayNum = 2;
                break;

               case 4:
                subarrayNum = 1;
                break;
              }
            } else {
              subarrayNum = 0;
            }

            numberOfAntennaInSubset = b_ant - subarrayNum;
            a = ((double)numberOfAntennaInSubset - 1.0) / 2.0;
            b_b = -((double)numberOfAntennaInSubset - 1.0) / 2.0;
            for (backw = 0; backw < 2; backw++) {
              /*  number fo subset of subcarriers chosen for smoothing music */
              i0 = matrixCSI->size[0] * matrixCSI->size[1] * matrixCSI->size[2];
              matrixCSI->size[0] = subCarrInd_size_idx_1;
              matrixCSI->size[1] = b_ant;
              matrixCSI->size[2] = loop_ub_tmp;
              emxEnsureCapacity_creal_T(matrixCSI, i0);
              for (i0 = 0; i0 < loop_ub_tmp; i0++) {
                for (i1 = 0; i1 < b_ant; i1++) {
                  for (i2 = 0; i2 < subCarrInd_size_idx_1; i2++) {
                    matrixCSI->data[(i2 + matrixCSI->size[0] * i1) +
                      matrixCSI->size[0] * matrixCSI->size[1] * i0] = y
                      [((subCarrInd_data[i2] + 120 * i1) + 960 * i0) - 1];
                  }
                }
              }

              i0 = smoothedMatrixCSI->size[0] * smoothedMatrixCSI->size[1] *
                smoothedMatrixCSI->size[2];
              smoothedMatrixCSI->size[0] = subCarrInd_size_idx_1;
              smoothedMatrixCSI->size[1] = b_ant;
              smoothedMatrixCSI->size[2] = loop_ub_tmp;
              emxEnsureCapacity_creal_T(smoothedMatrixCSI, i0);
              for (i0 = 0; i0 < b_loop_ub; i0++) {
                smoothedMatrixCSI->data[i0] = matrixCSI->data[i0];
              }

              if (iv0[backw] != 0) {
                columnsNum = ((b_ant - numberOfAntennaInSubset) + 1) *
                  ((subCarrInd_size_idx_1 - numberOfSubcarrierSubsets) + 1);
                i0 = matrixCSI->size[0] * matrixCSI->size[1] * matrixCSI->size[2];
                matrixCSI->size[0] = numberOfAntennaInSubset *
                  numberOfSubcarrierSubsets;
                matrixCSI->size[1] = (columnsNum << 1) * (2 - perSpec);
                matrixCSI->size[2] = numberOfSpectrums;
                emxEnsureCapacity_creal_T(matrixCSI, i0);
                loop_ub = numberOfAntennaInSubset * numberOfSubcarrierSubsets *
                  ((columnsNum << 1) * (2 - perSpec)) * numberOfSpectrums;
                for (i0 = 0; i0 < loop_ub; i0++) {
                  matrixCSI->data[i0].re = 0.0;
                  matrixCSI->data[i0].im = 0.0;
                }

                i0 = 2 - perSpec;
                loop_ub = numberOfSubcarrierSubsets * (varargin_2 -
                  numberOfSubcarrierSubsets) * b_ant;
                c_loop_ub = numberOfAntennaInSubset * numberOfSubcarrierSubsets *
                  columnsNum;
                d_loop_ub = numberOfSubcarrierSubsets * (((b_ant -
                  numberOfAntennaInSubset) + 1) * (varargin_2 -
                  numberOfSubcarrierSubsets));
                i1 = b_ant - numberOfAntennaInSubset;
                k = numberOfSubcarrierSubsets - 1;
                for (i2 = 0; i2 <= k; i2++) {
                  y_data[i2] = (signed char)(1 + i2);
                }

                for (t = 0; t < numberOfSpectrums; t++) {
                  for (i = 0; i < i0; i++) {
                    k = smoothedMatrixCSI->size[0];
                    e_loop_ub = smoothedMatrixCSI->size[1];
                    remaining = t * (2 - perSpec) + i;
                    for (i2 = 0; i2 < e_loop_ub; i2++) {
                      for (i3 = 0; i3 < k; i3++) {
                        csiFromEachPacket_data[i3 + k * i2] =
                          smoothedMatrixCSI->data[(i3 + smoothedMatrixCSI->size
                          [0] * i2) + smoothedMatrixCSI->size[0] *
                          smoothedMatrixCSI->size[1] * remaining];
                      }
                    }

                    i2 = D->size[0] * D->size[1] * D->size[2];
                    D->size[0] = numberOfSubcarrierSubsets;
                    D->size[1] = varargin_2 - numberOfSubcarrierSubsets;
                    D->size[2] = b_ant;
                    emxEnsureCapacity_creal_T(D, i2);
                    for (i2 = 0; i2 < loop_ub; i2++) {
                      D->data[i2].re = 0.0;
                      D->data[i2].im = 0.0;
                    }

                    for (m = 0; m < b_ant; m++) {
                      /*  mth antenna */
                      csiFromEachPacket_size[0] = numberOfSubcarrierSubsets;
                      for (i2 = 0; i2 < numberOfSubcarrierSubsets; i2++) {
                        b_csiFromEachPacket_data[i2] = csiFromEachPacket_data[i2
                          + k * m];
                      }

                      b_csiFromEachPacket_size[0] = varargin_2 -
                        numberOfSubcarrierSubsets;
                      e_loop_ub = (varargin_2 - numberOfSubcarrierSubsets) - 1;
                      for (i2 = 0; i2 <= e_loop_ub; i2++) {
                        c_csiFromEachPacket_data[i2] = csiFromEachPacket_data
                          [((numberOfSubcarrierSubsets + i2) + k * m) - 1];
                      }

                      hankel(b_csiFromEachPacket_data, csiFromEachPacket_size,
                             c_csiFromEachPacket_data, b_csiFromEachPacket_size,
                             c_tmp_data, c_tmp_size);
                      e_loop_ub = c_tmp_size[1];
                      for (i2 = 0; i2 < e_loop_ub; i2++) {
                        remaining = c_tmp_size[0];
                        for (i3 = 0; i3 < remaining; i3++) {
                          D->data[(i3 + D->size[0] * i2) + D->size[0] * D->size
                            [1] * m] = c_tmp_data[i3 + c_tmp_size[0] * i2];
                        }
                      }
                    }

                    i2 = De->size[0] * De->size[1];
                    De->size[0] = numberOfAntennaInSubset *
                      numberOfSubcarrierSubsets;
                    De->size[1] = columnsNum;
                    emxEnsureCapacity_creal_T(De, i2);
                    for (i2 = 0; i2 < c_loop_ub; i2++) {
                      De->data[i2].re = 0.0;
                      De->data[i2].im = 0.0;
                    }

                    for (b_index = 0; b_index < numberOfAntennaInSubset; b_index
                         ++) {
                      i2 = tmp->size[0] * tmp->size[1];
                      tmp->size[0] = numberOfSubcarrierSubsets;
                      tmp->size[1] = ((b_ant - numberOfAntennaInSubset) + 1) *
                        (varargin_2 - numberOfSubcarrierSubsets);
                      emxEnsureCapacity_creal_T(tmp, i2);
                      for (i2 = 0; i2 < d_loop_ub; i2++) {
                        tmp->data[i2].re = 0.0;
                        tmp->data[i2].im = 0.0;
                      }

                      for (j = 0; j <= i1; j++) {
                        i2 = j * (varargin_2 - numberOfSubcarrierSubsets) + 1;
                        if (i2 > (1 + j) * (varargin_2 -
                                            numberOfSubcarrierSubsets)) {
                          i2 = 0;
                        } else {
                          i2--;
                        }

                        k = D->size[0];
                        e_loop_ub = D->size[1];
                        nm1d2 = b_index + j;
                        for (i3 = 0; i3 < e_loop_ub; i3++) {
                          for (remaining = 0; remaining < k; remaining++) {
                            e_tmp_data[remaining + k * i3] = D->data[(remaining
                              + D->size[0] * i3) + D->size[0] * D->size[1] *
                              nm1d2];
                          }
                        }

                        for (i3 = 0; i3 < e_loop_ub; i3++) {
                          for (remaining = 0; remaining < k; remaining++) {
                            tmp->data[remaining + tmp->size[0] * (i2 + i3)] =
                              e_tmp_data[remaining + k * i3];
                          }
                        }
                      }

                      start_idx = (unsigned char)((unsigned int)b_index *
                        numberOfSubcarrierSubsets);
                      for (i2 = 0; i2 < numberOfSubcarrierSubsets; i2++) {
                        d_tmp_data[i2] = (unsigned char)(((unsigned int)
                          y_data[i2] + start_idx) - 1U);
                      }

                      k = tmp->size[1];
                      for (i2 = 0; i2 < k; i2++) {
                        e_loop_ub = tmp->size[0];
                        for (i3 = 0; i3 < e_loop_ub; i3++) {
                          De->data[d_tmp_data[i3] + De->size[0] * i2] =
                            tmp->data[i3 + tmp->size[0] * i2];
                        }
                      }
                    }

                    i2 = ((i * columnsNum) << 1) + 1;
                    if (i2 > (((1 + i) * columnsNum) << 1) - columnsNum) {
                      i2 = 0;
                    } else {
                      i2--;
                    }

                    k = De->size[1];
                    for (i3 = 0; i3 < k; i3++) {
                      e_loop_ub = De->size[0];
                      for (remaining = 0; remaining < e_loop_ub; remaining++) {
                        matrixCSI->data[(remaining + matrixCSI->size[0] * (i2 +
                          i3)) + matrixCSI->size[0] * matrixCSI->size[1] * t] =
                          De->data[remaining + De->size[0] * i3];
                      }
                    }
                  }
                }

                i0 = smoothedMatrixCSI->size[0];
                i1 = smoothedMatrixCSI->size[1];
                loop_ub = smoothedMatrixCSI->size[2];
                i2 = conjCsiTracePerPacket->size[0] *
                  conjCsiTracePerPacket->size[1] * conjCsiTracePerPacket->size[2];
                c_loop_ub = div_s32_floor(1 - i0, -1);
                conjCsiTracePerPacket->size[0] = c_loop_ub + 1;
                d_loop_ub = div_s32_floor(1 - i1, -1);
                conjCsiTracePerPacket->size[1] = d_loop_ub + 1;
                conjCsiTracePerPacket->size[2] = loop_ub;
                emxEnsureCapacity_creal_T(conjCsiTracePerPacket, i2);
                for (i2 = 0; i2 < loop_ub; i2++) {
                  for (i3 = 0; i3 <= d_loop_ub; i3++) {
                    for (remaining = 0; remaining <= c_loop_ub; remaining++) {
                      conjCsiTracePerPacket->data[(remaining +
                        conjCsiTracePerPacket->size[0] * i3) +
                        conjCsiTracePerPacket->size[0] *
                        conjCsiTracePerPacket->size[1] * i2].re =
                        smoothedMatrixCSI->data[(((i0 - remaining) +
                        smoothedMatrixCSI->size[0] * ((i1 - i3) - 1)) +
                        smoothedMatrixCSI->size[0] * smoothedMatrixCSI->size[1] *
                        i2) - 1].re;
                      conjCsiTracePerPacket->data[(remaining +
                        conjCsiTracePerPacket->size[0] * i3) +
                        conjCsiTracePerPacket->size[0] *
                        conjCsiTracePerPacket->size[1] * i2].im =
                        -smoothedMatrixCSI->data[(((i0 - remaining) +
                        smoothedMatrixCSI->size[0] * ((i1 - i3) - 1)) +
                        smoothedMatrixCSI->size[0] * smoothedMatrixCSI->size[1] *
                        i2) - 1].im;
                    }
                  }
                }

                i0 = 2 - perSpec;
                loop_ub = numberOfSubcarrierSubsets * (varargin_2 -
                  numberOfSubcarrierSubsets) * b_ant;
                c_loop_ub = numberOfAntennaInSubset * numberOfSubcarrierSubsets *
                  (((b_ant - numberOfAntennaInSubset) + 1) * (varargin_2 -
                    numberOfSubcarrierSubsets));
                d_loop_ub = numberOfSubcarrierSubsets * (((b_ant -
                  numberOfAntennaInSubset) + 1) * (varargin_2 -
                  numberOfSubcarrierSubsets));
                i1 = b_ant - numberOfAntennaInSubset;
                k = numberOfSubcarrierSubsets - 1;
                for (i2 = 0; i2 <= k; i2++) {
                  y_data[i2] = (signed char)(1 + i2);
                }

                for (t = 0; t < numberOfSpectrums; t++) {
                  for (i = 0; i < i0; i++) {
                    k = conjCsiTracePerPacket->size[0];
                    e_loop_ub = conjCsiTracePerPacket->size[1];
                    remaining = t * (2 - perSpec) + i;
                    for (i2 = 0; i2 < e_loop_ub; i2++) {
                      for (i3 = 0; i3 < k; i3++) {
                        csiFromEachPacket_data[i3 + k * i2] =
                          conjCsiTracePerPacket->data[(i3 +
                          conjCsiTracePerPacket->size[0] * i2) +
                          conjCsiTracePerPacket->size[0] *
                          conjCsiTracePerPacket->size[1] * remaining];
                      }
                    }

                    i2 = D->size[0] * D->size[1] * D->size[2];
                    D->size[0] = numberOfSubcarrierSubsets;
                    D->size[1] = varargin_2 - numberOfSubcarrierSubsets;
                    D->size[2] = b_ant;
                    emxEnsureCapacity_creal_T(D, i2);
                    for (i2 = 0; i2 < loop_ub; i2++) {
                      D->data[i2].re = 0.0;
                      D->data[i2].im = 0.0;
                    }

                    for (m = 0; m < b_ant; m++) {
                      /*  mth antenna */
                      csiFromEachPacket_size[0] = numberOfSubcarrierSubsets;
                      for (i2 = 0; i2 < numberOfSubcarrierSubsets; i2++) {
                        b_csiFromEachPacket_data[i2] = csiFromEachPacket_data[i2
                          + k * m];
                      }

                      b_csiFromEachPacket_size[0] = varargin_2 -
                        numberOfSubcarrierSubsets;
                      e_loop_ub = (varargin_2 - numberOfSubcarrierSubsets) - 1;
                      for (i2 = 0; i2 <= e_loop_ub; i2++) {
                        c_csiFromEachPacket_data[i2] = csiFromEachPacket_data
                          [((numberOfSubcarrierSubsets + i2) + k * m) - 1];
                      }

                      hankel(b_csiFromEachPacket_data, csiFromEachPacket_size,
                             c_csiFromEachPacket_data, b_csiFromEachPacket_size,
                             c_tmp_data, c_tmp_size);
                      e_loop_ub = c_tmp_size[1];
                      for (i2 = 0; i2 < e_loop_ub; i2++) {
                        remaining = c_tmp_size[0];
                        for (i3 = 0; i3 < remaining; i3++) {
                          D->data[(i3 + D->size[0] * i2) + D->size[0] * D->size
                            [1] * m] = c_tmp_data[i3 + c_tmp_size[0] * i2];
                        }
                      }
                    }

                    i2 = De->size[0] * De->size[1];
                    De->size[0] = numberOfAntennaInSubset *
                      numberOfSubcarrierSubsets;
                    De->size[1] = ((b_ant - numberOfAntennaInSubset) + 1) *
                      (varargin_2 - numberOfSubcarrierSubsets);
                    emxEnsureCapacity_creal_T(De, i2);
                    for (i2 = 0; i2 < c_loop_ub; i2++) {
                      De->data[i2].re = 0.0;
                      De->data[i2].im = 0.0;
                    }

                    for (b_index = 0; b_index < numberOfAntennaInSubset; b_index
                         ++) {
                      i2 = tmp->size[0] * tmp->size[1];
                      tmp->size[0] = numberOfSubcarrierSubsets;
                      tmp->size[1] = ((b_ant - numberOfAntennaInSubset) + 1) *
                        (varargin_2 - numberOfSubcarrierSubsets);
                      emxEnsureCapacity_creal_T(tmp, i2);
                      for (i2 = 0; i2 < d_loop_ub; i2++) {
                        tmp->data[i2].re = 0.0;
                        tmp->data[i2].im = 0.0;
                      }

                      for (j = 0; j <= i1; j++) {
                        i2 = j * (varargin_2 - numberOfSubcarrierSubsets) + 1;
                        if (i2 > (1 + j) * (varargin_2 -
                                            numberOfSubcarrierSubsets)) {
                          i2 = 0;
                        } else {
                          i2--;
                        }

                        k = D->size[0];
                        e_loop_ub = D->size[1];
                        nm1d2 = b_index + j;
                        for (i3 = 0; i3 < e_loop_ub; i3++) {
                          for (remaining = 0; remaining < k; remaining++) {
                            e_tmp_data[remaining + k * i3] = D->data[(remaining
                              + D->size[0] * i3) + D->size[0] * D->size[1] *
                              nm1d2];
                          }
                        }

                        for (i3 = 0; i3 < e_loop_ub; i3++) {
                          for (remaining = 0; remaining < k; remaining++) {
                            tmp->data[remaining + tmp->size[0] * (i2 + i3)] =
                              e_tmp_data[remaining + k * i3];
                          }
                        }
                      }

                      start_idx = (unsigned char)((unsigned int)b_index *
                        numberOfSubcarrierSubsets);
                      for (i2 = 0; i2 < numberOfSubcarrierSubsets; i2++) {
                        d_tmp_data[i2] = (unsigned char)(((unsigned int)
                          y_data[i2] + start_idx) - 1U);
                      }

                      k = tmp->size[1];
                      for (i2 = 0; i2 < k; i2++) {
                        e_loop_ub = tmp->size[0];
                        for (i3 = 0; i3 < e_loop_ub; i3++) {
                          De->data[d_tmp_data[i3] + De->size[0] * i2] =
                            tmp->data[i3 + tmp->size[0] * i2];
                        }
                      }
                    }

                    i2 = (((i * columnsNum) << 1) + columnsNum) + 1;
                    if (i2 > (((1 + i) * columnsNum) << 1)) {
                      i2 = 0;
                    } else {
                      i2--;
                    }

                    k = De->size[1];
                    for (i3 = 0; i3 < k; i3++) {
                      e_loop_ub = De->size[0];
                      for (remaining = 0; remaining < e_loop_ub; remaining++) {
                        matrixCSI->data[(remaining + matrixCSI->size[0] * (i2 +
                          i3)) + matrixCSI->size[0] * matrixCSI->size[1] * t] =
                          De->data[remaining + De->size[0] * i3];
                      }
                    }
                  }
                }
              } else {
                boffset = b_ant - numberOfAntennaInSubset;
                aoffset = boffset + 1;
                columnsNum = aoffset * ((subCarrInd_size_idx_1 -
                  numberOfSubcarrierSubsets) + 1);
                i0 = matrixCSI->size[0] * matrixCSI->size[1] * matrixCSI->size[2];
                matrixCSI->size[0] = numberOfAntennaInSubset *
                  numberOfSubcarrierSubsets;
                matrixCSI->size[1] = columnsNum * (2 - perSpec);
                matrixCSI->size[2] = numberOfSpectrums;
                emxEnsureCapacity_creal_T(matrixCSI, i0);
                loop_ub = numberOfAntennaInSubset * numberOfSubcarrierSubsets *
                  (columnsNum * (2 - perSpec)) * numberOfSpectrums;
                for (i0 = 0; i0 < loop_ub; i0++) {
                  matrixCSI->data[i0].re = 0.0;
                  matrixCSI->data[i0].im = 0.0;
                }

                i0 = 2 - perSpec;
                loop_ub = numberOfSubcarrierSubsets * (varargin_2 -
                  numberOfSubcarrierSubsets) * b_ant;
                c_loop_ub = numberOfAntennaInSubset * numberOfSubcarrierSubsets *
                  columnsNum;
                d_loop_ub = numberOfSubcarrierSubsets * (aoffset * (varargin_2 -
                  numberOfSubcarrierSubsets));
                k = numberOfSubcarrierSubsets - 1;
                for (i1 = 0; i1 <= k; i1++) {
                  y_data[i1] = (signed char)(1 + i1);
                }

                for (t = 0; t < numberOfSpectrums; t++) {
                  for (i = 0; i < i0; i++) {
                    k = smoothedMatrixCSI->size[0];
                    e_loop_ub = smoothedMatrixCSI->size[1];
                    remaining = t * (2 - perSpec) + i;
                    for (i1 = 0; i1 < e_loop_ub; i1++) {
                      for (i2 = 0; i2 < k; i2++) {
                        csiFromEachPacket_data[i2 + k * i1] =
                          smoothedMatrixCSI->data[(i2 + smoothedMatrixCSI->size
                          [0] * i1) + smoothedMatrixCSI->size[0] *
                          smoothedMatrixCSI->size[1] * remaining];
                      }
                    }

                    i1 = D->size[0] * D->size[1] * D->size[2];
                    D->size[0] = numberOfSubcarrierSubsets;
                    D->size[1] = varargin_2 - numberOfSubcarrierSubsets;
                    D->size[2] = b_ant;
                    emxEnsureCapacity_creal_T(D, i1);
                    for (i1 = 0; i1 < loop_ub; i1++) {
                      D->data[i1].re = 0.0;
                      D->data[i1].im = 0.0;
                    }

                    for (m = 0; m < b_ant; m++) {
                      /*  mth antenna */
                      csiFromEachPacket_size[0] = numberOfSubcarrierSubsets;
                      for (i1 = 0; i1 < numberOfSubcarrierSubsets; i1++) {
                        b_csiFromEachPacket_data[i1] = csiFromEachPacket_data[i1
                          + k * m];
                      }

                      b_csiFromEachPacket_size[0] = varargin_2 -
                        numberOfSubcarrierSubsets;
                      e_loop_ub = (varargin_2 - numberOfSubcarrierSubsets) - 1;
                      for (i1 = 0; i1 <= e_loop_ub; i1++) {
                        c_csiFromEachPacket_data[i1] = csiFromEachPacket_data
                          [((numberOfSubcarrierSubsets + i1) + k * m) - 1];
                      }

                      hankel(b_csiFromEachPacket_data, csiFromEachPacket_size,
                             c_csiFromEachPacket_data, b_csiFromEachPacket_size,
                             c_tmp_data, c_tmp_size);
                      e_loop_ub = c_tmp_size[1];
                      for (i1 = 0; i1 < e_loop_ub; i1++) {
                        remaining = c_tmp_size[0];
                        for (i2 = 0; i2 < remaining; i2++) {
                          D->data[(i2 + D->size[0] * i1) + D->size[0] * D->size
                            [1] * m] = c_tmp_data[i2 + c_tmp_size[0] * i1];
                        }
                      }
                    }

                    i1 = De->size[0] * De->size[1];
                    De->size[0] = numberOfAntennaInSubset *
                      numberOfSubcarrierSubsets;
                    De->size[1] = columnsNum;
                    emxEnsureCapacity_creal_T(De, i1);
                    for (i1 = 0; i1 < c_loop_ub; i1++) {
                      De->data[i1].re = 0.0;
                      De->data[i1].im = 0.0;
                    }

                    for (b_index = 0; b_index < numberOfAntennaInSubset; b_index
                         ++) {
                      i1 = tmp->size[0] * tmp->size[1];
                      tmp->size[0] = numberOfSubcarrierSubsets;
                      tmp->size[1] = aoffset * (varargin_2 -
                        numberOfSubcarrierSubsets);
                      emxEnsureCapacity_creal_T(tmp, i1);
                      for (i1 = 0; i1 < d_loop_ub; i1++) {
                        tmp->data[i1].re = 0.0;
                        tmp->data[i1].im = 0.0;
                      }

                      for (j = 0; j <= boffset; j++) {
                        i1 = j * (varargin_2 - numberOfSubcarrierSubsets) + 1;
                        if (i1 > (1 + j) * (varargin_2 -
                                            numberOfSubcarrierSubsets)) {
                          i1 = 0;
                        } else {
                          i1--;
                        }

                        k = D->size[0];
                        e_loop_ub = D->size[1];
                        nm1d2 = b_index + j;
                        for (i2 = 0; i2 < e_loop_ub; i2++) {
                          for (i3 = 0; i3 < k; i3++) {
                            e_tmp_data[i3 + k * i2] = D->data[(i3 + D->size[0] *
                              i2) + D->size[0] * D->size[1] * nm1d2];
                          }
                        }

                        for (i2 = 0; i2 < e_loop_ub; i2++) {
                          for (i3 = 0; i3 < k; i3++) {
                            tmp->data[i3 + tmp->size[0] * (i1 + i2)] =
                              e_tmp_data[i3 + k * i2];
                          }
                        }
                      }

                      start_idx = (unsigned char)((unsigned int)b_index *
                        numberOfSubcarrierSubsets);
                      for (i1 = 0; i1 < numberOfSubcarrierSubsets; i1++) {
                        d_tmp_data[i1] = (unsigned char)(((unsigned int)
                          y_data[i1] + start_idx) - 1U);
                      }

                      k = tmp->size[1];
                      for (i1 = 0; i1 < k; i1++) {
                        e_loop_ub = tmp->size[0];
                        for (i2 = 0; i2 < e_loop_ub; i2++) {
                          De->data[d_tmp_data[i2] + De->size[0] * i1] =
                            tmp->data[i2 + tmp->size[0] * i1];
                        }
                      }
                    }

                    i1 = i * columnsNum + 1;
                    if (i1 > (1 + i) * columnsNum) {
                      i1 = 0;
                    } else {
                      i1--;
                    }

                    k = De->size[1];
                    for (i2 = 0; i2 < k; i2++) {
                      e_loop_ub = De->size[0];
                      for (i3 = 0; i3 < e_loop_ub; i3++) {
                        matrixCSI->data[(i3 + matrixCSI->size[0] * (i1 + i2)) +
                          matrixCSI->size[0] * matrixCSI->size[1] * t] =
                          De->data[i3 + De->size[0] * i2];
                      }
                    }
                  }
                }
              }

              /*  smoothing completed */
              if (floor(a) == a) {
                remaining = (int)floor(-(b_b - a));
                b_index = remaining + 1;
                for (i0 = 0; i0 <= remaining; i0++) {
                  b_y_data[i0] = a - (double)i0;
                }
              } else {
                b_index = (int)floor((b_b - a) / -1.0 + 0.5);
                apnd = a + -(double)b_index;
                cdiff = b_b - apnd;
                if (fabs(cdiff) < 4.4408920985006262E-16 * fmax(a, fabs(b_b))) {
                  b_index++;
                  apnd = b_b;
                } else if (cdiff > 0.0) {
                  apnd = a + -((double)b_index - 1.0);
                } else {
                  b_index++;
                }

                b_y_data[0] = a;
                if (b_index > 1) {
                  b_y_data[b_index - 1] = apnd;
                  nm1d2 = (b_index - 1) / 2;
                  for (k = 0; k <= nm1d2 - 2; k++) {
                    b_y_data[1 + k] = a + -(1.0 + (double)k);
                    b_y_data[(b_index - k) - 2] = apnd - (-(1.0 + (double)k));
                  }

                  if (nm1d2 << 1 == b_index - 1) {
                    b_y_data[nm1d2] = (a + apnd) / 2.0;
                  } else {
                    b_y_data[nm1d2] = a + -(double)nm1d2;
                    b_y_data[nm1d2 + 1] = apnd - (-(double)nm1d2);
                  }
                }
              }

              for (i0 = 0; i0 < 21; i0++) {
                dcv0[i0].re = dv0[i0];
                dcv0[i0].im = 0.0;
              }

              tmp_size[0] = b_index;
              tmp_size[1] = 21;
              for (i0 = 0; i0 < b_index; i0++) {
                for (i1 = 0; i1 < 21; i1++) {
                  apnd = b_y_data[i0] * -0.0;
                  cdiff = b_y_data[i0] * -6.2831853071795862;
                  i2 = i0 + b_index * i1;
                  tmp_data[i2].re = apnd * dcv0[i1].re - cdiff * dcv0[i1].im;
                  tmp_data[i2].im = apnd * dcv0[i1].im + cdiff * dcv0[i1].re;
                }
              }

              c_exp(tmp_data, tmp_size);
              for (i0 = 0; i0 < numberOfSubcarrierSubsets; i0++) {
                b_csiFromEachPacket_data[i0].re = -0.0;
                b_csiFromEachPacket_data[i0].im = 312500.0 * ((double)
                  subCarrInd_data[i0] * -6.2831853071795862);
              }

              for (i0 = 0; i0 < 61; i0++) {
                dcv1[i0].re = dv1[i0];
                dcv1[i0].im = 0.0;
              }

              b_tmp_size[0] = numberOfSubcarrierSubsets;
              b_tmp_size[1] = 61;
              for (i0 = 0; i0 < numberOfSubcarrierSubsets; i0++) {
                for (i1 = 0; i1 < 61; i1++) {
                  b_tmp_data[i0 + numberOfSubcarrierSubsets * i1].re = -0.0 *
                    dcv1[i1].re - b_csiFromEachPacket_data[i0].im * dcv1[i1].im;
                  b_tmp_data[i0 + numberOfSubcarrierSubsets * i1].im = -0.0 *
                    dcv1[i1].im + b_csiFromEachPacket_data[i0].im * dcv1[i1].re;
                }
              }

              b_exp(b_tmp_data, b_tmp_size);
              kron(tmp_data, tmp_size, b_tmp_data, b_tmp_size, steeringVector);
              nsDelayAngleSpotfiEstimated->size[0] = 2;
              nsDelayAngleSpotfiEstimated->size[1] = 0;
              for (t = 0; t < numberOfSpectrums; t++) {
                loop_ub = matrixCSI->size[0];
                c_loop_ub = matrixCSI->size[1];
                i0 = mat->size[0] * mat->size[1];
                mat->size[0] = loop_ub;
                mat->size[1] = c_loop_ub;
                emxEnsureCapacity_creal_T(mat, i0);
                for (i0 = 0; i0 < c_loop_ub; i0++) {
                  for (i1 = 0; i1 < loop_ub; i1++) {
                    mat->data[i1 + mat->size[0] * i0] = matrixCSI->data[(i1 +
                      matrixCSI->size[0] * i0) + matrixCSI->size[0] *
                      matrixCSI->size[1] * t];
                  }
                }

                i0 = b->size[0] * b->size[1];
                b->size[0] = mat->size[1];
                b->size[1] = mat->size[0];
                emxEnsureCapacity_creal_T(b, i0);
                loop_ub = mat->size[0];
                for (i0 = 0; i0 < loop_ub; i0++) {
                  c_loop_ub = mat->size[1];
                  for (i1 = 0; i1 < c_loop_ub; i1++) {
                    b->data[i1 + b->size[0] * i0].re = mat->data[i0 + mat->size
                      [0] * i1].re;
                    b->data[i1 + b->size[0] * i0].im = -mat->data[i0 + mat->
                      size[0] * i1].im;
                  }
                }

                i0 = matrixCSI->size[1];
                if ((i0 == 1) || (b->size[0] == 1)) {
                  i0 = Rxx->size[0] * Rxx->size[1];
                  Rxx->size[0] = mat->size[0];
                  Rxx->size[1] = b->size[1];
                  emxEnsureCapacity_creal_T(Rxx, i0);
                  loop_ub = mat->size[0];
                  for (i0 = 0; i0 < loop_ub; i0++) {
                    c_loop_ub = b->size[1];
                    for (i1 = 0; i1 < c_loop_ub; i1++) {
                      Rxx->data[i0 + Rxx->size[0] * i1].re = 0.0;
                      Rxx->data[i0 + Rxx->size[0] * i1].im = 0.0;
                      d_loop_ub = mat->size[1];
                      for (i2 = 0; i2 < d_loop_ub; i2++) {
                        apnd = mat->data[i0 + mat->size[0] * i2].re * b->data[i2
                          + b->size[0] * i1].re - mat->data[i0 + mat->size[0] *
                          i2].im * b->data[i2 + b->size[0] * i1].im;
                        cdiff = mat->data[i0 + mat->size[0] * i2].re * b->
                          data[i2 + b->size[0] * i1].im + mat->data[i0 +
                          mat->size[0] * i2].im * b->data[i2 + b->size[0] * i1].
                          re;
                        Rxx->data[i0 + Rxx->size[0] * i1].re += apnd;
                        Rxx->data[i0 + Rxx->size[0] * i1].im += cdiff;
                      }
                    }
                  }
                } else {
                  i0 = matrixCSI->size[0];
                  i1 = matrixCSI->size[1];
                  remaining = b->size[1];
                  i2 = matrixCSI->size[0];
                  i3 = Rxx->size[0] * Rxx->size[1];
                  Rxx->size[0] = i2;
                  Rxx->size[1] = b->size[1];
                  emxEnsureCapacity_creal_T(Rxx, i3);
                  for (j = 0; j < remaining; j++) {
                    nm1d2 = j * i0;
                    boffset = j * i1;
                    for (i = 0; i < i0; i++) {
                      i2 = nm1d2 + i;
                      Rxx->data[i2].re = 0.0;
                      Rxx->data[i2].im = 0.0;
                    }

                    for (k = 0; k < i1; k++) {
                      aoffset = k * i0;
                      b_index = boffset + k;
                      apnd = b->data[b_index].re;
                      cdiff = b->data[b_index].im;
                      for (i = 0; i < i0; i++) {
                        b_index = aoffset + i;
                        temp_re = apnd * mat->data[b_index].re - cdiff *
                          mat->data[b_index].im;
                        temp_im = apnd * mat->data[b_index].im + cdiff *
                          mat->data[b_index].re;
                        i2 = nm1d2 + i;
                        Rxx->data[i2].re += temp_re;
                        Rxx->data[i2].im += temp_im;
                      }
                    }
                  }
                }

                eig(Rxx, Utmp);
                b_abs(Rxx, r1);
                diag(r1, d_data, csiFromEachPacket_size);
                b_csiFromEachPacket_size[0] = csiFromEachPacket_size[0];
                if (0 <= csiFromEachPacket_size[0] - 1) {
                  memcpy(&x_data[0], &d_data[0], (unsigned int)
                         (csiFromEachPacket_size[0] * (int)sizeof(double)));
                }

                sort(x_data, b_csiFromEachPacket_size, iidx_data,
                     csiFromEachPacket_size);
                loop_ub = csiFromEachPacket_size[0];
                for (i0 = 0; i0 < loop_ub; i0++) {
                  x_data[i0] = iidx_data[i0];
                }

                loop_ub = csiFromEachPacket_size[0];
                for (i0 = 0; i0 < loop_ub; i0++) {
                  b_d_data[i0] = d_data[(int)x_data[i0] - 1];
                }

                if (0 <= csiFromEachPacket_size[0] - 1) {
                  memcpy(&d_data[0], &b_d_data[0], (unsigned int)
                         (csiFromEachPacket_size[0] * (int)sizeof(double)));
                }

                columnsNum = 0;
                i0 = csiFromEachPacket_size[0];
                for (i = 0; i < i0; i++) {
                  if (d_data[i] < 1.0) {
                    columnsNum = 1 + i;
                  }
                }

                /*  eig completed */
                loop_ub = Utmp->size[0];
                c_loop_ub = Utmp->size[0];
                i0 = Pn->size[0] * Pn->size[1];
                Pn->size[0] = c_loop_ub;
                Pn->size[1] = csiFromEachPacket_size[0];
                emxEnsureCapacity_creal_T(Pn, i0);
                d_loop_ub = csiFromEachPacket_size[0];
                for (i0 = 0; i0 < d_loop_ub; i0++) {
                  for (i1 = 0; i1 < c_loop_ub; i1++) {
                    Pn->data[i1 + Pn->size[0] * i0] = Utmp->data[i1 + Utmp->
                      size[0] * ((int)x_data[i0] - 1)];
                  }
                }

                i0 = Rxx->size[0] * Rxx->size[1];
                Rxx->size[0] = loop_ub;
                Rxx->size[1] = columnsNum;
                emxEnsureCapacity_creal_T(Rxx, i0);
                for (i0 = 0; i0 < columnsNum; i0++) {
                  for (i1 = 0; i1 < loop_ub; i1++) {
                    Rxx->data[i1 + Rxx->size[0] * i0] = Pn->data[i1 + Pn->size[0]
                      * i0];
                  }
                }

                i0 = b->size[0] * b->size[1];
                b->size[0] = Rxx->size[1];
                b->size[1] = Rxx->size[0];
                emxEnsureCapacity_creal_T(b, i0);
                loop_ub = Rxx->size[0];
                for (i0 = 0; i0 < loop_ub; i0++) {
                  c_loop_ub = Rxx->size[1];
                  for (i1 = 0; i1 < c_loop_ub; i1++) {
                    b->data[i1 + b->size[0] * i0].re = Rxx->data[i0 + Rxx->size
                      [0] * i1].re;
                    b->data[i1 + b->size[0] * i0].im = -Rxx->data[i0 + Rxx->
                      size[0] * i1].im;
                  }
                }

                if ((columnsNum == 1) || (b->size[0] == 1)) {
                  i0 = Pn->size[0] * Pn->size[1];
                  Pn->size[0] = Rxx->size[0];
                  Pn->size[1] = b->size[1];
                  emxEnsureCapacity_creal_T(Pn, i0);
                  loop_ub = Rxx->size[0];
                  for (i0 = 0; i0 < loop_ub; i0++) {
                    c_loop_ub = b->size[1];
                    for (i1 = 0; i1 < c_loop_ub; i1++) {
                      Pn->data[i0 + Pn->size[0] * i1].re = 0.0;
                      Pn->data[i0 + Pn->size[0] * i1].im = 0.0;
                      d_loop_ub = Rxx->size[1];
                      for (i2 = 0; i2 < d_loop_ub; i2++) {
                        apnd = Rxx->data[i0 + Rxx->size[0] * i2].re * b->data[i2
                          + b->size[0] * i1].re - Rxx->data[i0 + Rxx->size[0] *
                          i2].im * b->data[i2 + b->size[0] * i1].im;
                        cdiff = Rxx->data[i0 + Rxx->size[0] * i2].re * b->
                          data[i2 + b->size[0] * i1].im + Rxx->data[i0 +
                          Rxx->size[0] * i2].im * b->data[i2 + b->size[0] * i1].
                          re;
                        Pn->data[i0 + Pn->size[0] * i1].re += apnd;
                        Pn->data[i0 + Pn->size[0] * i1].im += cdiff;
                      }
                    }
                  }
                } else {
                  i0 = Utmp->size[0];
                  remaining = b->size[1];
                  i1 = Utmp->size[0];
                  i2 = Pn->size[0] * Pn->size[1];
                  Pn->size[0] = i1;
                  Pn->size[1] = b->size[1];
                  emxEnsureCapacity_creal_T(Pn, i2);
                  for (j = 0; j < remaining; j++) {
                    nm1d2 = j * i0;
                    boffset = j * columnsNum;
                    for (i = 0; i < i0; i++) {
                      i1 = nm1d2 + i;
                      Pn->data[i1].re = 0.0;
                      Pn->data[i1].im = 0.0;
                    }

                    for (k = 0; k < columnsNum; k++) {
                      aoffset = k * i0;
                      b_index = boffset + k;
                      apnd = b->data[b_index].re;
                      cdiff = b->data[b_index].im;
                      for (i = 0; i < i0; i++) {
                        b_index = aoffset + i;
                        temp_re = apnd * Rxx->data[b_index].re - cdiff *
                          Rxx->data[b_index].im;
                        temp_im = apnd * Rxx->data[b_index].im + cdiff *
                          Rxx->data[b_index].re;
                        i1 = nm1d2 + i;
                        Pn->data[i1].re += temp_re;
                        Pn->data[i1].im += temp_im;
                      }
                    }
                  }
                }

                /*  Pn completed */
                if ((Pn->size[1] == 1) || (steeringVector->size[0] == 1)) {
                  i0 = b_y->size[0] * b_y->size[1];
                  b_y->size[0] = Pn->size[0];
                  b_y->size[1] = 1281;
                  emxEnsureCapacity_creal_T(b_y, i0);
                  loop_ub = Pn->size[0];
                  for (i0 = 0; i0 < loop_ub; i0++) {
                    for (i1 = 0; i1 < 1281; i1++) {
                      b_y->data[i0 + b_y->size[0] * i1].re = 0.0;
                      b_y->data[i0 + b_y->size[0] * i1].im = 0.0;
                      c_loop_ub = Pn->size[1];
                      for (i2 = 0; i2 < c_loop_ub; i2++) {
                        apnd = Pn->data[i0 + Pn->size[0] * i2].re *
                          steeringVector->data[i2 + steeringVector->size[0] * i1]
                          .re - Pn->data[i0 + Pn->size[0] * i2].im *
                          steeringVector->data[i2 + steeringVector->size[0] * i1]
                          .im;
                        cdiff = Pn->data[i0 + Pn->size[0] * i2].re *
                          steeringVector->data[i2 + steeringVector->size[0] * i1]
                          .im + Pn->data[i0 + Pn->size[0] * i2].im *
                          steeringVector->data[i2 + steeringVector->size[0] * i1]
                          .re;
                        b_y->data[i0 + b_y->size[0] * i1].re += apnd;
                        b_y->data[i0 + b_y->size[0] * i1].im += cdiff;
                      }
                    }
                  }
                } else {
                  m = Pn->size[0];
                  remaining = Pn->size[1];
                  i0 = b_y->size[0] * b_y->size[1];
                  b_y->size[0] = Pn->size[0];
                  b_y->size[1] = 1281;
                  emxEnsureCapacity_creal_T(b_y, i0);
                  for (j = 0; j < 1281; j++) {
                    nm1d2 = j * m;
                    boffset = j * remaining;
                    for (i = 0; i < m; i++) {
                      i0 = nm1d2 + i;
                      b_y->data[i0].re = 0.0;
                      b_y->data[i0].im = 0.0;
                    }

                    for (k = 0; k < remaining; k++) {
                      aoffset = k * m;
                      b_index = boffset + k;
                      apnd = steeringVector->data[b_index].re;
                      cdiff = steeringVector->data[b_index].im;
                      for (i = 0; i < m; i++) {
                        b_index = aoffset + i;
                        temp_re = apnd * Pn->data[b_index].re - cdiff * Pn->
                          data[b_index].im;
                        temp_im = apnd * Pn->data[b_index].im + cdiff * Pn->
                          data[b_index].re;
                        i0 = nm1d2 + i;
                        b_y->data[i0].re += temp_re;
                        b_y->data[i0].im += temp_im;
                      }
                    }
                  }
                }

                i0 = b_steeringVector->size[0] * b_steeringVector->size[1];
                b_steeringVector->size[0] = 1281;
                b_steeringVector->size[1] = steeringVector->size[0];
                emxEnsureCapacity_creal_T(b_steeringVector, i0);
                loop_ub = steeringVector->size[0];
                for (i0 = 0; i0 < loop_ub; i0++) {
                  for (i1 = 0; i1 < 1281; i1++) {
                    apnd = steeringVector->data[i0 + steeringVector->size[0] *
                      i1].re;
                    cdiff = -steeringVector->data[i0 + steeringVector->size[0] *
                      i1].im;
                    temp_re = b_y->data[i0 + b_y->size[0] * i1].re;
                    temp_im = b_y->data[i0 + b_y->size[0] * i1].im;
                    i2 = i1 + 1281 * i0;
                    b_steeringVector->data[i2].re = apnd * temp_re - cdiff *
                      temp_im;
                    b_steeringVector->data[i2].im = apnd * temp_im + cdiff *
                      temp_re;
                  }
                }

                sum(b_steeringVector, dcv2);
                c_abs(dcv2, SpotfiSpectrum);
                for (i0 = 0; i0 < 1281; i0++) {
                  SpotfiSpectrum[i0] = 1.0 / SpotfiSpectrum[i0];
                }

                if (!rtIsNaN(SpotfiSpectrum[0])) {
                  b_index = 1;
                } else {
                  b_index = 0;
                  k = 2;
                  exitg1 = false;
                  while ((!exitg1) && (k < 1282)) {
                    if (!rtIsNaN(SpotfiSpectrum[k - 1])) {
                      b_index = k;
                      exitg1 = true;
                    } else {
                      k++;
                    }
                  }
                }

                if (b_index == 0) {
                  apnd = SpotfiSpectrum[0];
                } else {
                  apnd = SpotfiSpectrum[b_index - 1];
                  i0 = b_index + 1;
                  for (k = i0; k < 1282; k++) {
                    cdiff = SpotfiSpectrum[k - 1];
                    if (apnd > cdiff) {
                      apnd = cdiff;
                    }
                  }
                }

                for (i0 = 0; i0 < 1281; i0++) {
                  SpotfiSpectrum[i0] -= apnd;
                }

                /*  spotfi completed */
                imregionalmax(SpotfiSpectrum, isPeak);
                b_index = 0;
                remaining = 0;
                exitg1 = false;
                while ((!exitg1) && (remaining < 1281)) {
                  if (isPeak[remaining]) {
                    b_index++;
                    ii_data[b_index - 1] = (short)(remaining + 1);
                    if (b_index >= 1281) {
                      exitg1 = true;
                    } else {
                      remaining++;
                    }
                  } else {
                    remaining++;
                  }
                }

                if (1 > b_index) {
                  b_index = 0;
                }

                for (i0 = 0; i0 < b_index; i0++) {
                  ii_data[i0]--;
                }

                for (i0 = 0; i0 < b_index; i0++) {
                  vk_data[i0] = (signed char)(ii_data[i0] / 61);
                }

                for (i0 = 0; i0 < b_index; i0++) {
                  ii_data[i0] = (short)(ii_data[i0] - vk_data[i0] * 61);
                }

                for (i0 = 0; i0 < b_index; i0++) {
                  ii_data[i0]++;
                }

                for (i0 = 0; i0 < b_index; i0++) {
                  vk_data[i0]++;
                }

                boffset = 0;
                for (i = 0; i < 1281; i++) {
                  if (isPeak[i]) {
                    boffset++;
                  }
                }

                remaining = 0;
                for (i = 0; i < 1281; i++) {
                  if (isPeak[i]) {
                    f_tmp_data[remaining] = (short)(i + 1);
                    remaining++;
                  }
                }

                for (i0 = 0; i0 < boffset; i0++) {
                  varargin_1_data[i0] = SpotfiSpectrum[f_tmp_data[i0] - 1];
                }

                if (boffset <= 2) {
                  if (boffset == 1) {
                    apnd = SpotfiSpectrum[f_tmp_data[0] - 1];
                  } else {
                    apnd = SpotfiSpectrum[f_tmp_data[1] - 1];
                    if ((SpotfiSpectrum[f_tmp_data[0] - 1] < apnd) || (rtIsNaN
                         (SpotfiSpectrum[f_tmp_data[0] - 1]) && (!rtIsNaN(apnd))))
                    {
                    } else {
                      apnd = SpotfiSpectrum[f_tmp_data[0] - 1];
                    }
                  }
                } else {
                  if (!rtIsNaN(varargin_1_data[0])) {
                    b_index = 1;
                  } else {
                    b_index = 0;
                    k = 2;
                    exitg1 = false;
                    while ((!exitg1) && (k <= boffset)) {
                      if (!rtIsNaN(varargin_1_data[k - 1])) {
                        b_index = k;
                        exitg1 = true;
                      } else {
                        k++;
                      }
                    }
                  }

                  if (b_index == 0) {
                    apnd = SpotfiSpectrum[f_tmp_data[0] - 1];
                  } else {
                    apnd = SpotfiSpectrum[f_tmp_data[b_index - 1] - 1];
                    i0 = b_index + 1;
                    for (k = i0; k <= boffset; k++) {
                      cdiff = SpotfiSpectrum[f_tmp_data[k - 1] - 1];
                      if (apnd < cdiff) {
                        apnd = cdiff;
                      }
                    }
                  }
                }

                cdiff = 0.1 * apnd;
                for (i0 = 0; i0 < boffset; i0++) {
                  isStrongEnough_data[i0] = (SpotfiSpectrum[f_tmp_data[i0] - 1] >
                    cdiff);
                }

                b_index = boffset - 1;
                nm1d2 = 0;
                for (i = 0; i <= b_index; i++) {
                  if (isStrongEnough_data[i]) {
                    nm1d2++;
                  }
                }

                remaining = 0;
                for (i = 0; i <= b_index; i++) {
                  if (isStrongEnough_data[i]) {
                    ii_data[remaining] = ii_data[i];
                    remaining++;
                  }
                }

                b_index = boffset - 1;
                boffset = 0;
                for (i = 0; i <= b_index; i++) {
                  if (isStrongEnough_data[i]) {
                    boffset++;
                  }
                }

                remaining = 0;
                for (i = 0; i <= b_index; i++) {
                  if (isStrongEnough_data[i]) {
                    vk_data[remaining] = vk_data[i];
                    remaining++;
                  }
                }

                for (i0 = 0; i0 < nm1d2; i0++) {
                  newEstimation_data[i0 << 1] = (-3.0000000000000004E-7 +
                    ((double)ii_data[i0] - 1.0) * 1.0000000000000002E-8) *
                    1.0E+9;
                }

                for (i0 = 0; i0 < boffset; i0++) {
                  newEstimation_data[1 + (i0 << 1)] = -90.0 + ((double)
                    vk_data[i0] - 1.0) * 9.0;
                }

                for (i0 = 0; i0 < nm1d2; i0++) {
                  g_tmp_data[i0] = (newEstimation_data[1 + (i0 << 1)] > -89.0);
                }

                for (i0 = 0; i0 < nm1d2; i0++) {
                  h_tmp_data[i0] = (newEstimation_data[1 + (i0 << 1)] < 89.0);
                }

                b_index = nm1d2 - 1;
                boffset = 0;
                for (i = 0; i <= b_index; i++) {
                  if (g_tmp_data[i] && h_tmp_data[i]) {
                    boffset++;
                  }
                }

                remaining = 0;
                for (i = 0; i <= b_index; i++) {
                  if (g_tmp_data[i] && h_tmp_data[i]) {
                    i_tmp_data[remaining] = (short)(i + 1);
                    remaining++;
                  }
                }

                for (i0 = 0; i0 < boffset; i0++) {
                  remaining = (i_tmp_data[i0] - 1) << 1;
                  b_index = i0 << 1;
                  b_newEstimation_data[b_index] = newEstimation_data[remaining];
                  b_newEstimation_data[1 + b_index] = newEstimation_data[1 +
                    remaining];
                }

                loop_ub = 2 * boffset;
                if (0 <= loop_ub - 1) {
                  memcpy(&newEstimation_data[0], &b_newEstimation_data[0],
                         (unsigned int)(loop_ub * (int)sizeof(double)));
                }

                i0 = b_nsDelayAngleSpotfiEstimated->size[0] *
                  b_nsDelayAngleSpotfiEstimated->size[1];
                b_nsDelayAngleSpotfiEstimated->size[0] = 2;
                b_nsDelayAngleSpotfiEstimated->size[1] =
                  nsDelayAngleSpotfiEstimated->size[1] + boffset;
                emxEnsureCapacity_real_T(b_nsDelayAngleSpotfiEstimated, i0);
                loop_ub = nsDelayAngleSpotfiEstimated->size[1];
                for (i0 = 0; i0 < loop_ub; i0++) {
                  i1 = i0 << 1;
                  b_nsDelayAngleSpotfiEstimated->data[i1] =
                    nsDelayAngleSpotfiEstimated->data[i1];
                  i1++;
                  b_nsDelayAngleSpotfiEstimated->data[i1] =
                    nsDelayAngleSpotfiEstimated->data[i1];
                }

                for (i0 = 0; i0 < boffset; i0++) {
                  i1 = i0 << 1;
                  b_nsDelayAngleSpotfiEstimated->data[(i0 +
                    nsDelayAngleSpotfiEstimated->size[1]) << 1] =
                    newEstimation_data[i1];
                  b_nsDelayAngleSpotfiEstimated->data[1 + ((i0 +
                    nsDelayAngleSpotfiEstimated->size[1]) << 1)] =
                    newEstimation_data[1 + i1];
                }

                i0 = nsDelayAngleSpotfiEstimated->size[0] *
                  nsDelayAngleSpotfiEstimated->size[1];
                nsDelayAngleSpotfiEstimated->size[0] = 2;
                nsDelayAngleSpotfiEstimated->size[1] =
                  b_nsDelayAngleSpotfiEstimated->size[1];
                emxEnsureCapacity_real_T(nsDelayAngleSpotfiEstimated, i0);
                loop_ub = b_nsDelayAngleSpotfiEstimated->size[0] *
                  b_nsDelayAngleSpotfiEstimated->size[1];
                for (i0 = 0; i0 < loop_ub; i0++) {
                  nsDelayAngleSpotfiEstimated->data[i0] =
                    b_nsDelayAngleSpotfiEstimated->data[i0];
                }

                /*  peaks completed */
                /*                                  fileID = fopen(directory+"SpotfiEigen" + seed_str + ".txt", 'a'); */
                /*                                  fprintf(fileID, "noise: "); */
                /*                                  for i = 1:numberOfSourses */
                /*                                      fprintf(fileID, "%.3f ", d(i)); */
                /*                                  end */
                /*                                  fprintf(fileID, "signal: "); */
                /*                                  for i = numberOfSourses+1:length(d) */
                /*                                      fprintf(fileID, "%.3f ", d(i)); */
                /*                                  end */
                /*                                  fprintf(fileID, "\n"); */
                /*                                  fclose(fileID); */
              }

              obj_Value[0] = 'r';
              obj_Value[1] = '_';
              for (i0 = 0; i0 < 5; i0++) {
                obj_Value[i0 + 2] = seed_str[i0];
                obj_Value[i0 + 7] = cv2[i0];
              }

              string_string(b_ant, filename_Value_data, c_tmp_size);
              string_plus(obj_Value, filename_Value_data, c_tmp_size,
                          name_Value_data, name_Value_size);
              b_string_plus(name_Value_data, name_Value_size,
                            filename_Value_data, c_tmp_size);
              string_string(1.0 - (double)smoothing, name_Value_data,
                            name_Value_size);
              c_string_plus(filename_Value_data, c_tmp_size, name_Value_data,
                            name_Value_size, t0_Value_data, t0_Value_size);
              d_string_plus(t0_Value_data, t0_Value_size, filename_Value_data,
                            c_tmp_size);
              string_string(1.0 - (double)backw, name_Value_data,
                            name_Value_size);
              c_string_plus(filename_Value_data, c_tmp_size, name_Value_data,
                            name_Value_size, t0_Value_data, t0_Value_size);
              e_string_plus(t0_Value_data, t0_Value_size, filename_Value_data,
                            c_tmp_size);
              string_string(b_p, name_Value_data, name_Value_size);
              c_string_plus(filename_Value_data, c_tmp_size, name_Value_data,
                            name_Value_size, t0_Value_data, t0_Value_size);
              f_string_plus(t0_Value_data, t0_Value_size, filename_Value_data,
                            c_tmp_size);
              string_string(2.0 - (double)perSpec, name_Value_data,
                            name_Value_size);
              c_string_plus(filename_Value_data, c_tmp_size, name_Value_data,
                            name_Value_size, t0_Value_data, t0_Value_size);
              g_string_plus(t0_Value_data, t0_Value_size, filename_Value_data,
                            c_tmp_size);
              h_string_plus(filename_Value_data, c_tmp_size, name_Value_data,
                            name_Value_size);
              i_string_plus(name_Value_data, name_Value_size,
                            filename_Value_data, c_tmp_size);
              string_string(dec, name_Value_data, name_Value_size);
              c_string_plus(filename_Value_data, c_tmp_size, name_Value_data,
                            name_Value_size, t0_Value_data, t0_Value_size);
              j_string_plus(t0_Value_data, t0_Value_size, name_Value_data,
                            name_Value_size);
              b_obj_Value[0] = '.';
              b_obj_Value[1] = '/';
              for (i0 = 0; i0 < 11; i0++) {
                b_obj_Value[i0 + 2] = subdir_Value[i0];
              }

              b_obj_Value[13] = '/';
              k_string_plus(b_obj_Value, name_Value_data, name_Value_size,
                            filename_Value_data, c_tmp_size);
              fileid = c_cfopen(filename_Value_data, c_tmp_size, "wb");
              i0 = nsDelayAngleSpotfiEstimated->size[1];
              for (j = 0; j < i0; j++) {
                b_NULL = NULL;
                getfilestar(fileid, &filestar, &autoflush);
                if (!(filestar == b_NULL)) {
                  fprintf(filestar, "%.1f ", nsDelayAngleSpotfiEstimated->data[j
                          << 1]);
                  if (autoflush) {
                    fflush(filestar);
                  }
                }

                if (!(filestar == b_NULL)) {
                  fprintf(filestar, "%.1f ", nsDelayAngleSpotfiEstimated->data[1
                          + (j << 1)]);
                  if (autoflush) {
                    fflush(filestar);
                  }
                }
              }

              b_fclose(fileid);
            }
          }
        }
      }
    }
  }

  emxFree_real_T(&b_nsDelayAngleSpotfiEstimated);
  emxFree_creal_T(&b_steeringVector);
  emxFree_real_T(&r1);
  emxFree_creal_T(&b_y);
  emxFree_creal_T(&b);
  emxFree_creal_T(&Utmp);
  emxFree_creal_T(&Pn);
  emxFree_creal_T(&Rxx);
  emxFree_creal_T(&mat);
  emxFree_real_T(&nsDelayAngleSpotfiEstimated);
  emxFree_creal_T(&steeringVector);
  emxFree_creal_T(&conjCsiTracePerPacket);
  emxFree_creal_T(&tmp);
  emxFree_creal_T(&De);
  emxFree_creal_T(&D);
  emxFree_creal_T(&smoothedMatrixCSI);
  emxFree_creal_T(&matrixCSI);

  /*  Spotfi */
}

/*
 * File trailer for forCoder.c
 *
 * [EOF]
 */
